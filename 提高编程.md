# C++learning
[toc]

本阶段主要针对C++**泛型编程**和**STL**技术做详细讲解，探讨cpp更深层的使用
# 一、模板
## 1.1 模板的概念
模板就是建立**通用的摸具**，大大提高**复用性**  
模板的特点： 
- 模板不可以直接使用，它只是一个框架
- 模板的通用并不是万能的

## 1.2 函数模板
- C++另一种编程思想称为**泛型编程**，主要利用的技术就是模板
- C++提供两种模板机制：**函数模板**和**类模板**
### 1.2.1 函数模板用法
函数模板作用：  
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。  
**语法**：
```cpp
template<typename T> 
函数声明或定义
```
**解释**：  
template —— 声明创建模板  
typename —— 表明其后面的符号是一种数据类型，可以用class代替  
T —— 通用的数据类型，名称可以替换，通常为大写字母  
**示例**：  
```cpp
#include <iostream>
using namespace std;

template <typename T>
void mySwap(T a, T b)
{
	T temp = a;
	a = b;
	b = temp;
}


void test01()
{
	char a = 'a', b = 'b';
	// 1. 自动类型推导
	//mySwap(a, b);
	//cout << "a=" << a << " " << "b=" << b << endl;

	// 2. 显示指定类型
	mySwap<int>(a, b);
	cout << "a=" << a << " " << "b=" << b << endl;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
函数模板利用关键字template  
使用函数模板有两种方式：自动类型推导、显示指定类型  
模板的目的是为了提高复用性，将类型参数化

### 1.2.2 函数模板注意事项
注意事项：  
- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用  
示例：
```cpp
template<class T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

// 1. 自动类型推导，必须推导出一致的数据类型T，才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	mySwap(a, b); // 正确，可以推导出一致的T
	//mySwap(a, c); // 错误，推到不出一致的T类型
}

// 2. 模板必须要确定出T的数据类型，才可以使用
template<class T>
void func()
{
	cout << "func 的调用" << endl;
}

void test02()
{
	//func(); // 错误，模板不能独立使用，必须确定出T的类型
	func<int>(); // 利用显示指定类型的方式，给T一个类型，才可以使用该模板
}

int main()
{
	test01();
	test02();

	system("pause");
	return 0;
}
```
>小结：  
使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型

### 1.2.3 函数模板案例
案例描述：
- 利用函数模板封装一个排序的函数，可以对**不同数据类型数组进行**排序
- 排序规则为从大到小，排序算法为**选择排序**
- 分别利用**char数组**和**int数组**进行测试  
示例：
```cpp
template <class T>
void mySort(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		int max = i;
		for (int j = i + 1; j < len; j++)
		{
			if (arr[j] > arr[max])
			{
				max = j;
			}
		}
		if (max != i) // swap;
		{
			int tmp = arr[i];
			arr[i] = arr[max];
			arr[max] = tmp;
		}
	}
}

template <class T>
void printRes(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}

void test01()
{
	char charArr[] = "asdasdasd";
	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);
	printRes(charArr, num);
}

```
>小结：  
模板可以提高代码复用，需要熟练掌握

### 1.2.4 普通函数与函数模板的区别
**区别：**
- 普通函数调用时可以发生自动类型转换（隐式类型转换）
- 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
- 如果利用显示指定类型的方式，可以发生隐式类型转换
**示例：**
```cpp
template<class T>
T myAdd(T a, T b)
{
	return a + b;
}
// 在普通函数里是可以数字加上字符类型的，字符会转换成对应ASCII码
// 但是在函数模板中不可以发生自动类型转换，需要使用显示指定类型才可以发生隐式类型转换：
myAdd<int>(a, c);
```
>小结：  
建议使用显式指定类型的方式，调用函数模板，因为可以自己确定通用类型T

### 1.2.5 普通函数与函数模板的调用规则
调用规则如下：
1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载：```myPrint<>(a, b)```
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

>小结：  
既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

### 1.2.6 模板的局限性
局限性：
- 模板的通用性并不是万能的

例如：
```cpp
template<class T>
void f(T a, T b)
{
	a = b;
}
```
在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了  
再例如：
```cpp
template<class T>
void f(T a, T b)
{
	if (a > b) {...}
}
```
在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行  
因此cpp为了解决这种问题，提供模板的**重载**，可以为这些特定的类型提供**具体化**的模板  
示例：
```cpp
template <class T>
bool myCompare(T a, T b)
{
	if (a = b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

// 具体化，以template<>开头，并通过名称来指出类型
// 具体化优先于常规模板
template<> bool myCompare(Person& p1, Person& p2)
{
	if (p1, name == p2.name ......)
		....
}
```
>小结：  
利用具体化的模板，可以解决自定义类型的通用化  
学习模板并不是为了写模板，而是在STL能够运用系统提供的模板


## 1.3 类模板
### 1.3.1 类模板语法
类模板作用：
- 建立一个通用类，类中的成员 数据类型可以不具体指定，用一个**虚拟的类型**来代表。

语法：
```cpp
template<class T>
类
```
解释：  
template —— 声明创建模板  
typename/class —— 表明其后面的符号是一种数据类型，可以用class代替  
T —— 通用的数据类型，名称可以替换，通常为大写字母  
示例：
```cpp
#include <iostream>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->name = name;
		this->age = age;
	}
	void showPerson()
	{
		cout << "Name : " << name << " Age: " << age << endl;
	}

public:
	NameType name;
	AgeType age;
};


void test01()
{
	// 类模板使用只能用显示指定类型方式
	Person<string, int> p("美猴王", 33);
	p.showPerson();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板

### 1.3.2 类模板与函数模板区别
类模板与函数模板区别主要有两点：
1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

示例：
```cpp
Person<string, int> p("美猴王", 33); // 1. 
template<class NameType, class AgeType = int>
Person<string> p("美猴王"); // 2.
```

### 1.3.3 类模板中成员函数创建时机
类模板中成员函数和普通类中成员函数创建时机是有区别的：
- 普通类中的成员函数一开始就可以创建
- 类模板中的成员函数在调用时创建

示例：
```cpp
class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show" << endl;
	}
};

class MyClass2
{
public:
	void func()
	{
		obj.showPerson1(); // 需指定数据类型才可调用
	}

public:
	Person1 obj;
};

template<class T>
class MyClass
{
public:
	T obj;

	// 类模板中的成员函数，并不是在一开始就创建的，而是在模板调用时再生成
	void func1() { obj.showPerson1(); }
	void func2() { obj.showPerson2(); }
};


void test01()
{
	MyClass<Person1> m;
	m.func1();
	//m.func2(); // 编译出错，说明函数调用才会去创建成员函数
}
```
>小结：  
类模板中的成员函数并不是一开始就创建的，在调用时才去创建

### 1.3.4 类模板对象做函数参数
类模板实例化出的对象，向函数传参的方式   
一共有三种传入方式：
1. 指定传入的类型 —— 直接显示对象的数据类型
2. 参数模板化 —— 将对象中的参数变为模板进行传递
3. 整个类模板化 —— 将这个对象类型 模板化进行传递

示例：
```cpp
// 1.指定传入类型
void func1(Person<string, int> &p)
{
	...
}

// 2.参数模板化
template<class T1, class T2>
void func2(Person<T1, T2> &p)
{
	...
}

// 3.整个类模板化
template<class T>
void func3(T &p)
{
	...
}

void test()
{
	Person <string, int> p("猪猪侠", 18);
	func123(p);
}
```
>小结：  
通过类模板创建的对象，可以有三种方式向函数中进行传参  
使用比较广泛的是第一种：指定传入的类型

### 1.3.5 类模板与继承
当类模板碰到继承时，需要注意以下几点：
- 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
- 如果不指定，编译器无法给子类分配内存
- 如果想灵活指定出父类中T的类型，子类也需要变为类模板

示例：
```cpp
template<class T>
class Base
{
public:
	T m;
};

//class Son :public Base // 错误，cpp编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son : public Base<int>
{
public:
	Son(int m)
	{
		this->m = m;
		cout << this->m << endl;
	}
};

// 类模板继承类模板，可以用T2指定父类中的T类型
template<class T1, class T2>
class Son2 : public Base<T2>
{
public:
	Son2()
	{
		cout << typeid(T1).name() << endl;
		cout << typeid(T2).name() << endl;
	}
};


void test01()
{
	Son s(3);
	Son2<int, char> s2;
}
```
>小结：  
如果父类是类模板，子类需要指定出父类中T的数据类型

### 1.3.6 类模板成员函数类外实现
示例：
```cpp
// 构造成员函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) 
{
	...
}

// 成员函数 类外实现
template<class T1, class T2> 
void Person<T1, T2>::showPerson() // 注意<>的位置
{
	...
}
```
>小结：  
类模板中成员函数类外实现时，需要加上模板参数列表

### 1.3.7 类模板 分文件编写
掌握类模板成员函数分文件编写产生的问题以及解决方式  
问题：
- 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决：
- 方法1：直接包含.cpp源文件
- 方法2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

示例：  
person.hpp
```cpp
#pragma once
#include <iostream>
using namespace std;

template <class T1, class T2>
class Person
{
public:
	Person(T1 name, T2 age);
	void showPerson();

public:
	T1 name;
	T2 age;
};

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->name = name;
	this->age = age;
}

template <class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "Name :" << this->name << " Age:" << age << endl;
}
```
main.cpp
```cpp
//#include "person.cpp" // 解决方式1，包含cpp
#include "person.hpp" // 解决方式2，将声明和实现写在一起，文件后缀名改为.hpp

void test01()
{
	Person<string, int> p("张三", 13);
	p.showPerson();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp

### 1.3.8 类模板与友元
掌握类模板配合友元函数的类内和类外实现  
全局函数类内实现 —— 直接在类内声明友元即可  
全局函数类外实现 —— 需要提前让编译器知道全局函数的存在  
示例：
```cpp
// 2. 全局函数配合友元 类外实现 —— 先做函数模板声明，下方再做函数模板定义，再做友元
template<class T1, class T2> class Person;

// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
template<class T1, class T2>
void printPerson2(Person<T1, T2>& p)
{
	
}

template<class T1, class T2>
class Person
{
	// 1. 全局函数配合友元 类内实现
	friend void printPerson(Person<T1, T2>& p)
	{
		...
	}

	// 2. 全局函数配合友元 类外实现
	friend void printPerson2<>(Person<T1, T2>& p);

private:
	T1 name;
	T2 age;
};
```
>小结：  
建议全局函数做类内实现，用法简单，而且编译器可以直接识别

### 1.3.9 类模板案例
案例描述：实现一个通用的数组类，要求如下：
- 可以对内置数据类型以及自定义数据类型的数据进行存储
- 将数组中的数据存储到堆区
- 构造函数中可以传入数组的容量
- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
- 提供尾插法和尾删法对数组中的数据进行增加和删除
- 可以通过下标的方式访问数组中的元素
- 可以获取数组中当前元素个数和数组的容量

示例：  
myArray.hpp
```cpp
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
	// 构造函数
	MyArray(int capacity)
	{
		this->m_Capacity = capacity;
		this->m_Size = 0;
		pAddress = new T[this->m_Capacity];
	}

	// 拷贝构造
	MyArray(const MyArray& arr)
	{
		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			// 如果T为对象，而且还包含指针，必须需要重载=操作符，因为这个等号不是构造而是赋值
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	// 重载 = 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& arr)
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}

		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	// 重载[] 操作符 arr[0]
	T& operator [](int index)
	{
		return this->pAddress[index];
	}

	// 尾插法
	void Push_back(const T& val)
	{
		if (this->m_Capacity == this->m_Size)
		{
			return;
		}
		this->pAddress[this->m_Size] = val;
		this->m_Size++;
	}

	// 尾删法
	void Pop_back()
	{
		if (this->m_Size == 0)
		{
			return;
		}
		this->m_Size--;
	}

	// 获取数组容量
	int getCapacity()
	{
		return this->m_Capacity;
	}

	// 获取数组大小
	int getSize()
	{
		return this->m_Size;
	}

	// 析构
	~MyArray()
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->pAddress = NULL;
			this->m_Size = 0;
			this->m_Capacity = 0;
		}
	}

private:
	T* pAddress; // 指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; // 容量
	int m_Size; // 大小
};
```
main.cpp测试：
```cpp
#include "MyArray.hpp"

void test01()
{
	MyArray<int> a1(10); // 可初始化各种数据类型，包括自定义数据类型
	for (int i = 0; i < 10; i++)
	{
		a1.Push_back(i);
		cout << a1[i] << endl;
	}
	cout << a1.getSize() << endl;
	
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
利用所学知识点实现通用的数组


# 二、STL初始
## 2.1 STL的诞生
- 长久以来，软件界一直希望建立一种可重复利用的东西
- cpp的**面向对象**和**泛型编程**思想，目的就是**复用性的提升**
- 大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
- 为了建立数据结构和算法的一套标准，诞生了**STL**

## 2.2 STL基本概念
- STL（Standard Template Library，标准模板库）
- STL从广义上分为：容器 算法 迭代器
- **容器**和**算法**之间通过**迭代器**进行无缝连接
- STL几乎所有的代码都采用了模板类或者模板函数

## 2.3 STL六大组件
STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
1. 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂
4. 仿函数：行为类似函数，可作为算法的某种策略
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西
6. 空间适配器：负责空间的配置和管理

## 2.4 STL中容器、算法、迭代器
**STL容器**：置物之所也；将运用最广泛的一些数据结构实现出来  
常用的数据结构：数组、链表、树、栈、队列、集合、映射表等   
这些容器分为**序列式容器**和**关联式容器**两种：  
序列式：强调值得排序，序列式容器中的每个元素均有固定的位置
关联式：二叉树结构，各元素之间没有严格的物理上的顺序关系

**算法**：问题之解法也；有限的步骤解决逻辑或数学上的问题  
算法分为：**质变算法**和**非质变算法**：  
质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝、替换、删除等等  
非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等  

**迭代器**：容器和算法之间粘合剂；提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。  
每个容器都有自己专属的迭代器  
迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针  
迭代器种类：  
1. 输入迭代器：只读 ++ ==
2. 输出迭代器：只写 ++
3. 前向迭代器：读写 ++ ==
4. 双向迭代器：读写 ++ --
5. 随机访问迭代器：读写，跳跃访问 +5 [n] >=

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器

## 2.5 容器算法迭代器初识
了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力  
STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器
### 2.5.1 vector存放内置数据类型
容器：```vector```  
算法：```for_each```  
迭代器：```vector<int>::iterator```  
示例：
```cpp
#include <iostream>
#include <vector> // vector用
#include <algorithm> // for_each用
using namespace std;

void func(int n)
{
	cout << n + 1 << endl;
}

void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

	// 每个容器都有自己的迭代器，迭代器用来遍历容器中的元素
	vector<int>::iterator pBegin = v.begin(); // 返回迭代器，指向容器中第一个数据
	vector<int>::iterator pEnd = v.end();  // 返回迭代器，指向容器元素的最后一个元素的下一个位置

	// 方法一
	while (pBegin != pEnd)
	{
		cout << *pBegin << endl;
		pBegin++;
	}

	// 方法二
	for (vector<int>::iterator i = v.begin(); i != v.end(); i++)
	{
		cout << *i << endl;
	}

	// 方法三
	// 使用STL提供的标准遍历算法 头文件 algorithm
	for_each (v.begin(), v.end(), func);
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 2.5.2 Vector存放自定义数据类型
Vector中存放自定义数据类型，并打印输出  
示例：
```cpp
// 存放对象
for (vector<Person>::iterator it = v.begin(); it != v.end()l it ++)
{
	cout << (*it).name;
	cout << it->name;
}

// 存放指针
vector<Person*> v;
Person p1("aaa", 10);
v.push_back(&p1);

for (vector<Person*>::iterator it = v.begin(); it != v.end()l it ++)
{
	cout << (*it)->name // *it是Person *类型
}
```

### 2.5.3 Vector容器嵌套容器
示例：
```cpp
for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it ++)
{
	for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++)
	{
		cout << *vit << endl;
	}
}
```


# 三、STL - 常用容器
## 3.1 string容器
### 3.1.1 string基本概念
**本质**：
- string是cpp风格的字符串，而string本质上是一个类
**string**和**char***的区别：  
- char* 是一个指针
- string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器

**特点**：  
string类内部封装了很多成员方法  
例如：查找find，拷贝copy，删除delete，替换replace，插入insert  
string管理char*所分配的内存，不用担心赋值越界和取值越界等，由类内部进行负责  

### 3.1.2 string构造函数  
构造函数原型：
- string(); 创建一个空的字符串 例如：string str；  
string(const char* s); 使用字符串s初始化
- string(const string& str); 使用一个string对象初始化另一个string对象
- string(int n, char c); 使用n个字符c初始化
```cpp
string s1; // 创建空字符串，调用无参构造函数
cout << "str1 = " << s1 << endl; // 啥也不输出

const char* str = "hello world";
string s2(str); // 把c_string转换成了string
cout << "str2 = " << s2 << endl;

string s3(s2); // 调用拷贝构造函数
cout << "str3 = " << s3 << endl;

string s4(10, 'a');
cout << "str4 = " << s4 << endl;
```
>小结：  
string的多轴构造方式没有可比性，灵活使用即可

### 3.1.3 string赋值操作
功能描述：给string字符串进行赋值  
赋值的函数原型：
- ```string& operator=(const char* s);``` // char*类型字符串 赋值给当前的字符串
- ```string& operator=(const string &s);``` // 把字符串s赋给当前的字符串
- ```string& operator=(char c);``` // 字符赋值给当前的字符串
- ```string& assign(const char *s);``` // 把字符串s赋给当前的字符串
- ```string& assign(const char *s, int n);``` // 把字符串s的前n个字符赋给当前的字符串
- ```string& assign(const string &s);``` // 把字符串s赋给当前字符串
- ```string& assign(int n, char c);``` // 用n个字符c赋给当前字符串

示例：
```cpp
string s1 = "hello world";

string s2 = s1;

string s3;
s3 = 'a';

string s4;
s4.assign("hello cpp");

string s5;
s5.assign("helloaaaa", 5);

string s6;
s6.assign(s5);

string s7;
s7.assign(5, 'x');

cout << s7;
```
>小结：  
string的赋值方式很多，```operator=```这种方式是比较常用的

### 3.1.4 string字符串拼接
**功能描述**：
- 实现在字符串末尾拼接字符串

函数原型：
- ```string& operator+=(const char* str);``` // 重载+=操作符 
- ```string& operator+=(const char c);``` // 重载+=操作符
- ```string& operator+=(const string& str);``` // 重载+=操作符
- ```string& append(const char *s);``` // 把字符串s连接到当前字符串结尾
- ```string& append(const char *s, int n);``` // 把字符串s的前n个字符连接到当前字符串结尾
- ```string& append(const string &s);``` // 同operator+=(const string &str)
- ```string& append(const string &s, int pos, int n);``` // 字符串s中从pos开始的n个字符连接到字符串结尾
```cpp
string s1 = "我";

s1 += "爱玩游戏";

string s2 = "哈哈DNFFFF";
s1 += s2;

string s3 = "I";
s3.append("love");
s3.append("your girlfriend", 4);

s3.append(s2, 4, 3);
cout << s3 << endl;
```
>小结：  
字符串拼接的重载版本很多，初学阶段记住几种即可

### 3.1.5 string查找和替换
**功能描述**：  
- 查找：查找指定字符串是否存在
- 替换：在指定的位置替换字符串

函数原型：  
左到右查找：
- ```int find(const string& str, int pos = 0) const;``` // 查找str第一次出现位置，从pos开始查找
- ```int find(const char* s, int pos = 0) const;``` // 查找s第一次出现位置，从pos开始查找
- ```int find(const char* s, int pos, int n) const;``` // 从pos位置查找s的前n个字符第一次位置
- ```int find(const char c, int pos = 0) const;``` // 查找字符c第一次出现位置

(本质是右到左查找：
- ```int rfind(const string& str, int pos = npos) const;``` // 查找str最后一次出现位置即从右往左的第一次，从pos开始查找
- ```int rfind(const char* s, int pos = npos) const;``` // 查找s最后一次出现位置，从pos开始查找
- ```int rfind(const char* s, int pos, int n) const;``` // 从pos位置查找s的前n个字符最后一次位置
- ```int rfind(const char c, int pos = 0) const;``` // 查找字符最后一次出现位置

替换：
- ```string& replace(int pos, int n, const string& str);``` // 替换从pos开始n个字符为字符串str
- ```string& replace(int pos, int n, const char*s);``` // 替换从pos开始n个字符为字符串s

```cpp
string s = "this is";
cout << s.find("is") << endl; // 2
cout << s.rfind("is") << endl; // 5
```
>小结：  
find查找是从左往右，rfind是从右往左  
find找到字符串后返回查找的第一个字符位置，找不到返回-1  
replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串

### 3.1.6 string字符串比较
**功能描述**：字符串之间的比较  
**比较方式**：按照字符的ASCII码进行对比  
= 返回 0  
\> 返回 1  
< 返回 -1  
**函数原型**：  
- int compare(const string &s) const; // 与字符串s比较
- int compare(const char *s) const; // 与字符串s比较  
示例：
```cpp
string s1 = "hello";
string s2 = "aello";

int res = s1.compare(s2);

cout << res << endl; // a在h前 输出1
```

### 3.1.7 string字符存取
string中单个字符存取方式有两种
- ```char& operator[](int n);``` // 通过[]方式取字符
- ```char& at(int n);``` // 通过at方法获取字符
```cpp
string s1 = "hello";
string s2 = "aello";

for (int i = 0; i < s1.size(); i++)
{
	cout << s1[i] << endl;
	cout << s1.at(i) << endl;
}

s1[0] = 'a';
s1.at(1) = 'b';
cout << s1 << endl;
```

### 3.1.8 string插入和删除
**功能描述**：对string字符串进行插入和删除字符操作，起始下标都从0开始  
**函数原型**：
- ```string& insert(int pos, const char *s);``` // 插入字符串
- ```string& insert(int pos, const string &str);``` // 插入字符串
- ```string& insert(int pos, int n, char c);``` // 在指定位置插入n个字符c
- ```string& erase(int pos, int n = npos);``` // 删除从Pos开始的n个字符

示例：
```cpp
void test01()
{
	string s1 = "hello";
	
	s1.insert(1, "111");
	cout << s1 << endl;

	s1.erase(1, 3);
	cout << s1 << endl;
}
```

### 3.1.9 string子串
**功能描述**：从字符串中获取想要的字符串   
**函数原型**：
- ```string substr(int pos = 0, int n = npos) const; // 返回由pos开始的n个字符组成的字符串
```cpp
void test01()
{
	string s1 = "hello";
	string substr = s1.substr(1, 3);
	cout << substr << endl;

	string email = "lwl@163.com";
	int pos = email.find("@");
	string name = email.substr(0, pos);
	cout << name << endl;
}
```

## 3.2 vector容器
### 3.2.1 vector基本概念
**功能描述**：vector数据结构和数组非常相似，也称为**单端数组**  
vector与普通数组区别：
- 不同之处在于数组是静态控件，而vector可以**动态扩展**

**动态扩展**：
- 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间
- vector容器的迭代器是支持随机访问的迭代器

### 3.2.2 vector构造函数
**功能描述**：创建vector容器  
**函数原型**：
- ```vector<T> v;``` // 采用模板实现类实现，默认构造函数
- ```vector(v.begin(), v.end());``` // 将v.begin(), v.end()中间的元素拷贝给自身
- ```vector(n, elem);``` // 构造函数将n个elem拷贝给本身
- ```vector(const vector &vec);``` // 拷贝构造函数

示例：
```cpp
void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}

	vector<int> v2(v1.begin(), v1.end());

	vector<int> v3(10, 100);

	vector<int> v4 (v3);

	for (int i = 0; i < 10; i++)
	{
		cout << v3[i] << endl;
	}
}
```

### 3.2.3 vector赋值操作
**功能描述**：给vector容器进行赋值  
**函数原型**：
- ```vector& operator=(const vector &vec);``` // 重载等号操作符
- ```assign(beg, end);``` // 将[beg, end)区间中的数据拷贝赋值给本身
- ```assign(n, elem);``` // 将n个elem拷贝赋值给本身
```cpp
void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}

	vector<int> v2;
	v2 = v1;
	printVector(v2);

	vector<int> v3;
	v3.assign(v1.begin(), v1.end());
	printVector(v3);

	vector<int> v4;
	v4.assign(10, 100);
	printVector(v4);
}
```

### 3.2.4 vector容量和大小
**功能描述**：对vector容器的容量和大小操作  
**函数原型**：
- ```empty();``` 判断容器是否为空
- ```capacity();```容器的容量
- ```size();``` 返回容器中元素的个数
- ```resize(int num);``` 重新指定容器的长度为num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
- ```resize(int num, elem);``` 重新指定容器的长度为num，若容器变长，则以elem值填充新位置；若容器变短，则末尾超出容器长度的元素被删除
```cpp
void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	cout << v1.capacity() << endl;

	v1.resize(15, 10);
	cout << v1.capacity() << endl;
	printVector(v1);

	v1.resize(5);
	cout << v1.capacity() << endl;
	printVector(v1);
}
```

### 3.2.5 vector插入和删除
**功能描述**：对vector进行插入、删除操作  
**函数原型**：
- ```push_back(ele);``` 尾部插入元素ele
- ```pop_back();``` 删除最后一个元素
- ```insert(const_iterator pos, ele);``` 迭代器指向位置pos插入元素ele
- ```insert(const_iterator pos, int count, ele);``` 迭代器指向位置pos插入count个元素ele
- ```erase(const_iterator pos);``` 删除迭代器指向的元素
- ```erase(consr_iterator start, const_iterator end);``` 删除迭代器从start到end之间的元素
- ```clear();``` 删除容器中所有元素

示例：
```cpp
void test01()
{
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);

	v1.pop_back();
	printVector(v1);

	v1.insert(v1.begin(), 100);
	printVector(v1);

	v1.insert(v1.begin(), 3, 20); 
	printVector(v1);

	v1.erase(v1.begin(), v1.end());
	printVector(v1);

	v1.clear();
	printVector(v1);
}
```

### 3.2.6 vector数据存取
**功能描述**：对vector中的数据的存取操作  
**函数原型**：  
- ```at(int idx);``` 返回索引idx所指的数据
- ```operator[];``` 返回索引idx所指的数据
- ```front();``` 返回容器中第一个数据元素
- ```back();``` 返回容器中最后一个数据元素
```cpp
void test01()
{
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);

	v1.pop_back();
	cout << v1.back() << endl;

	cout << v1.front()<< endl;

	v1.insert(v1.begin(), 3, 20); 
	printVector(v1);
	cout << v1.at(3) << endl;
}
```

### 3.2.7 vector互换容器
**功能描述**：实现两个容器内元素进行互换  
**函数原型**：
- ```swap(vec);``` 将vec与本身的元素互换

示例：
```cpp
void test01()
{
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);

	vector<int> v2;
	v2.push_back(30);
	v2.push_back(20);
	v2.push_back(10);

	v1.swap(v2);
	printVector(v1);
	printVector(v2);

	v2.resize(1);
	printVector(v2);
	cout << v2.capacity() << endl; // 3
	// 重点：巧用swap收缩内存
	vector<int>(v2).swap(v2);
	cout << v2.capacity() << endl; // 1
}
```

### 3.2.8 vector预留空间
**功能描述**：减少vector在动态扩展容量时的扩展次数  
**函数原型**：
- ```reserve(int len);``` 容器预留len个元素长度，预留位置不初始化，元素不可访问
```cpp
void test01()
{
	vector<int> v;

	// 预留空间
	v.reserve(100000);

	int num = 0;
	int* p = NULL;
	for (int i = 0; i < 100000; i++)
	{
		v.push_back(i);
		if (p != &v[0]) // 在达到预留空间数前不需要再继续动态扩容
		{
			p = &v[0];
			num++;
		}
	}

	cout << num << endl;
}
```

## 3.3 deque容器
### 3.3.1 deque容器基本概念
**功能**：双端数组，可以对头端进行插入删除操作  
**deque**与**vector**区别：
- vector对于头部的插入删除效率低，数据量越大，效率越低
- deque相对而言，对头部的插入删除速度会比vector快
- vector访问元素时的速度会比deque快，这和两者内部实现有关

deque**内部**工作原理：  
deque内部有个**中控器**，维护每段缓冲区中的内容，缓冲区中存放真实数据  
中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间  
deque容器的迭代器也是支持随机访问的

### 3.3.2 deque构造函数
**功能描述**：deque容器构造  
**函数原型**：
- ```deque<T> deqT;``` 默认构造形式
- ```deque(beg, end);``` 构造函数将[beg, end)区间中的元素拷贝给本身
- ```deque(n, elem);``` 构造函数将n个elem拷贝给本身
- ```deque(const deque &deq);``` 拷贝构造函数

示例：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <deque>
using namespace std;

void printDeque(const deque<int>& d)
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	deque<int> d1;
	for (int i = 0; i < 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	deque<int> d2(d1.begin(), d1.end());
	printDeque(d2);

	deque<int> d3(3, 33);
	printDeque(d3);

	deque<int>d4 = d3;
	printDeque(d4);
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 3.3.3 deque赋值操作
**功能描述**：给deque容器进行赋值  
**函数原型**：
- ```deque& operator=(const deque &deq);``` 重载等号操作符
- ```assign(beg, end);``` 将[beg, end)区间中的数据拷贝赋值给本身
- ```assign(n, elem);``` 将n个elem拷贝赋值给本身

### 3.3.4 deque大小操作
同vector；但deque**没有容量**概念

### 3.3.5 deque插入和删除
**功能描述**：向deque容器中插入和删除数据  
**函数原型**：  
两端插入操作：  
- ```push_back(elem);``` 在容器尾部添加一个数据
- ```push_front(elem);``` 在容器头部插入一个数据
- ```pop_back();``` 删除容器最后一个数据
- ```pop_front();``` 删除容器第一个数据

指定位置操作：
- ```insert(pos, elem);``` 在pos位置插入一个elem元素的拷贝，返回新数据的位置
- ```insert(pos, n, elem);``` 在pos位置插入n个elem数据，无返回值
- ```insert(pos, beg, end);``` 在pos位置插入[beg, end)区间的数据，无返回值
- ```clear();``` 清空容器的所有数据
- ```erase(beg, end)``` 删除[beg, end)区间的数据，返回下一个数据的位置
- ```erase(pos);``` 删除pos位置的数据，返回下一个数据的位置

示例：
```cpp
void test01()
{
	deque<int> d1;
	d1.push_back(10);
	d1.push_back(20);

	d1.push_front(100);
	d1.push_front(200);

	printDeque(d1);

	d1.pop_front();
	d1.pop_back();
	printDeque(d1);

	d1.insert(d1.begin(), 300);
	d1.insert(d1.end(), 3, 400);
	d1.insert(d1.begin(), d1.begin(), d1.end());
	d1.erase(d1.begin());
	d1.erase(d1.begin(), d1.end());
	d1.clear();
	printDeque(d1);
}
```

### 3.3.6 deque数据存取
同vector；

### 3.3.7 deque排序
算法：
- ```sort(iterator beg, iterator end)``` 对beg和end区间内元素进行排序  

算法实现：
```cpp
sort(d1.begin(), d1.end()); // 使用时包含头文件algorithm即可
```

## 3.4 案例-评委打分
### 3.4.1 案例描述
有五名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分

### 3.4.2 实现步骤
1. 创建五名选手，放到vector中
2. 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中
3. sort算法对deque容器中分数排序，去除最高和最低分
4. deque容器遍历一遍，累加总分
5. 获取平均分

示例代码：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>
using namespace std;

class Person
{
public:
	Person(string name, int score)
	{
		this->name = name;
		this->score = score;
	}

public:
	string name;
	int score;
};

void createPerson(vector<Person>& v)
{
	string nameSeed = "ABCDE";

	for (int i = 0; i < 5; i++)
	{
		string name = "选手";
		name += nameSeed[i];

		int score = 0;

		Person p(name, score);

		v.push_back(p);
	}
}

void setScore(vector<Person> &v)
{
	for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	{
		deque<int> d;
		for (int i = 0; i < 10; i++)
		{
			int score = rand() % 41 + 60;
			d.push_back(score);
		}

		sort(d.begin(), d.end());

		// 去除最高和最低分
		d.pop_back();
		d.pop_front();

		int sum = 0;
		for (deque<int>::iterator dit = d.begin(); dit != d.end(); dit++)
		{
			sum += *dit;
		}

		int avg = sum / d.size();

		it->score = avg;
	}
}

void showScore(vector<Person>& v)
{
	for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << "姓名：" << it->name << " 分数：" << it->score << endl;
	}
}


int main()
{
	// 随机数种子
	srand((unsigned int)time(NULL));

	// 1.创建五名选手
	vector<Person> v; // 存放选手容器
	createPerson(v);

	//for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	//{
	//	cout << (*it).name << endl;
	//}

	// 2. 给五名选手打分
	setScore(v);

	// 3. 显示最后得分
	showScore(v);

	system("pause");
	return 0;
}
```

## 3.5 stack容器
### 3.5.1 stack基本概念
**概念**：stack是一种**先进后出**（FILO）的数据结构，它只有一个出口  
栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为  
栈中进入程序称为 —— **入栈**```push```  
栈中弹出数据称为 —— **出栈**```pop```  

### 3.5.2 stack常用接口
**功能描述**：栈容器常用的对外接口  
构造函数：  
- ```stack<T> stk;``` stack采用模板类实现，stack对象的默认构造形式  
- ```stack(const stack &stk);``` 拷贝构造函数

赋值操作：  
- ```stack &operator=(const stack &stk);``` 重载等号操作符

数据存取：
- ```push(elem);``` 向栈顶添加元素
- ```pop();``` 从栈顶移除第一个元素
- ```top();``` 返回栈顶元素

大小操作：
- ```empty();``` 判断堆栈是否为空
- ```size();``` 返回栈的大小

示例：
```cpp
void test01()
{
	stack<int> stk;

	stk.push(10);
	stk.push(20);
	stk.push(30);

	while (!stk.empty())
	{
		cout << stk.top() << endl;
		stk.pop();
	}
	cout << stk.size();
}
```

## 3.6 queue容器
### 3.6.1 queue基本概念
**概念**：Queue是一种**先进先出**（FIFO）的数据结构，它有两个出口  
队列容器允许从一端新增元素，从另一端移除元素  
队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为  
队列中进数据称为 —— **入队**```push```
队列中出数据称为 —— **出队**```pop```  

### 3.6.2 queue常用接口
**功能描述**：栈容器常用的对外接口  
构造函数：
- ```queue<T> que;``` queue采用模板类实现，queue对象的默认构造形式
- ```queue(const queue &que);``` 拷贝构造函数

赋值操作：
- ```queue& operator=(const queue &que);``` 重载等号操作符

数据存取：
- ```push(elem);``` 往队尾添加元素
- ```pop();``` 从队头移除第一个元素
- ```back();``` 返回最后一个元素
- ```front();``` 返回第一个元素

大小操作：
- ```empty();``` 判断堆栈是否为空
- ```size();``` 返回栈的大小

## 3.7 list容器
### 3.7.1 list基本概念
**功能**：将数据进行链式存储  
**链表**（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的  
链表的组成：链表是由一系列**结点**组成  
结点的组成：一个是存储数据元素的**数据域**，另一个是存储下一个结点地址的**指针域**  
STL中的链表是一个双向循环链表  
由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于**双向迭代器**  
list的**优点**：
- 采用动态存储分配，不会造成内存浪费和溢出
- 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素

list的**缺点**：
- 链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大

list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的  
总结：STL中**list**和**vector**是两个最常被使用的容器，各有优缺点

### 3.7.2 list构造函数
**功能描述**：创建list容器  
**函数原型**：
- ```list<T> lst;``` list采用模板类实现，对象的默认构造形式
- ```list(beg, end);``` 构造函数将[beg, end)区间中的元素拷贝给本身
- ```list(n, elem);``` 构造函数将n个elem拷贝给本身
- ```list(const list &lst);``` 拷贝构造函数

示例：
```cpp
void printList(const list<int>& L)
{
	for (list<int>::const_iterator it = L.begin(); it != L.end(); it++)
	{
		cout << *it << endl;
	}
}

void test01()
{
	list<int> l1;
	l1.push_back(10);
	l1.push_back(20);
	l1.push_back(30);
	l1.push_back(40);

	printList(l1);

	list<int>l2(l1.begin(), l1.end());
	printList(l2);

	list<int> l3(l2);
	printList(l3);

	list<int>l4(100, 19);
	printList(l4);
}
```
>小结：  
list构造方式同其他几个STL常用容器，熟练掌握即可

### 3.7.3 list赋值和交换
**功能描述**：给list容器进行赋值，以及交换list容器  
**函数原型**：
- ```assign(beg, end);``` 将[beg, end)区间中的数据拷贝赋值给本身
- ```assign(n, elem);``` 将n个elem拷贝赋值给本身
- ```list& operator=(const list &lst);``` 重载等号操作符
- ```swap(lst);``` 将lst与本身的元素互换

示例：
```cpp
list<int> l1;
list<int> l2;
l2 = l1;

list<int> l3;
l3.assign(l2.begin(), l2.end());

list<int> l4;
l4.assign(10, 100);

l3.swap(l4);
```

### 3.7.4 list大小操作
**功能描述**：对list容器的大小进行操作  
**函数原型**：
- ```size();``` 返回容器中元素的个数
- ```empty();``` 判断容器是否为空
- ```resize(num);``` 重新指定容器的长度为num，若容器变长，则以默认值填充新位置；若容器变短，则末尾超出容器长度的元素被删除
- ```resize(num, elem);``` 重新指定容器的长度为num，若容器变长，则以elem值填充新位置；若容器变短，则末尾超出容器长度的元素被删除

示例：
```cpp
list<int> l1;
l1.resize(10);
l1.resize(2);
```

### 3.7.5 list插入和删除
**功能描述**：对list容器进行数据的插入和删除  
**函数原型**：
- ```push_back(elem);``` 在容器尾部加入一个元素
- ```pop_back();``` 删除容器中最后一个元素
- ```push_front(elem);``` 在容器开头插入一个元素
- ```pop_front();``` 从容器开头移除第一个元素
- ```insert(pos, elem);``` 在pos位置插elem元素的拷贝，返回新数据的位置
- ```insert(pos, n, elem);``` 在pos位置插入n个elem数据，无返回值
- ```insert(pos, beg, end);``` 在pos位置插入[beg, end)区间的数据，无返回值
- ```clear();``` 移除容器的所有数据
- ```erase(beg, end);``` 删除[beg, end)区间的数据，返回下一个数据的位置
- ```erase(pos);``` 删除pos位置的数据，返回下一个数据的位置
- ```remove(elem);``` 删除容器中所有与elem值匹配的元素

示例：
```cpp
list<int>::iterator it = l1.begin();
l1.insert(++it, 100);
printList(l1);
```

### 3.7.6 list数据获取
**功能描述**：对list容器中数据进行存取  
**函数原型**：
- ```front();``` 返回第一个元素
- ```back();``` 返回最后一个元素

示例：
```cpp
l1.front();
l1.back();

// l1.at(0); // 不支持at访问数据
// l1[0]; // 不支持[]方式访问数据

// list容器的迭代器是双向迭代器，
list<int>::iterator it = l1.begin();
it ++;
it --;

//但不支持随机访问，即使是+1
// it = it + 1;
```

### 3.7.7 list反转和排序
**功能描述**：将容器中的元素反转，以及将容器中的数据进行排序  
**函数原型**：
- ```reverse();``` 反转链表
- ```sort();``` 链表排序

示例：
```cpp
bool myCompare(int v1, int v2)
{
	return v1 > v2;
}

void test01()
{
	list<int> l1;
	l1.push_back(10);
	l1.push_back(30);
	l1.push_back(80);
	l1.push_back(40);

	l1.reverse();
	printList(l1);
	
	l1.sort();
	printList(l1);

	l1.sort(myCompare); // 可以自定义排序方法
	printList(l1);
}
```
>小结：  
对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序  
高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂

## 3.8 set/multiset容器
### 3.8.1 set基本概念
简介：
- 所有元素都会在插入时自动被排序

本质：
- set/multiset属于**关联式容器**，底层结构用**二叉树**实现

set和multiset区别：
- set不允许容器中有重复的元素
- multiset允许容器中有重复的元素

### 3.8.2 set构造和赋值
**功能描述**：创建set容器以及赋值  
**构造**：
- ```set<T> st;``` 默认构造函数
- ```set(const set &st);``` 拷贝构造函数

赋值：
- ```set& operator=(const set &st);``` 重载等号操作

示例
```cpp
void printSet(set<int>& s)
{
	for (set<int>::iterator it = s.begin(); it != s.end(); it++)
	{
		cout << *it << endl;
	}
}

void test01()
{
	set<int> s1;

	s1.insert(10);
	s1.insert(40);
	s1.insert(20);
	s1.insert(30);
	s1.insert(40);
	printSet(s1);

	set<int> s2(s1);

	set<int> s3;
	s3 = s2;
	printSet(s3);
}
```
>小结：  
set容器插入数据时用insert  
set容器插入的数据会自动排序

### 3.8.3 set大小和交换
**功能描述**：统计set容器大小以及交换set容器  
**函数原型**：
- ```size();``` 返回容器中元素的数目
- ```empty();``` 判断容器是否为空
- ```swap(st);``` 交换两个集合容器

示例：
```cpp
void test01()
{
	set<int> s1;

	s1.insert(10);
	s1.insert(40);
	s1.insert(20);
	s1.insert(30);
	s1.insert(40);

	set<int> s2;
	s2.insert(60);
	s2.insert(80);
	s2.insert(90);
	s2.insert(70);
	
	s1.swap(s2);
	printSet(s1);
}
```

### 3.8.4 set插入和删除
**功能描述**：set容器进行插入数据和删除数据  
**函数原型**：
- ```insert(elem);``` 在容器中插入元素  
- ```clear();``` 清除所有元素
- ```erase(pos);``` 删除pos迭代器所指的元素，返回下一个元素的迭代器
- ```erase(beg, end)``` 删除[beg, end)的所有元素，返回下一个元素的迭代器
- ```erase(elem);``` 删除容器中值为elem的元素

示例：
```cpp
s1.erase(10);
```

### 3.8.5 set查找和统计
**功能描述**：对set容器进行查找数据以及统计数据  
**函数原型**：
- ```find(key);``` 查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();
- ```count(key);``` 统计key的元素个数

示例：
```cpp
set<int>::iterator pos = s1.find(30);
if (pos != s1.end())
{
	cout << *pos << endl;
}

int num = s1.count(30);
```
>小结：  
find（返回的是迭代器）  
count（对于set，结果为0或者1）

### 3.8.6 set和multiset的区别
**区别**：
- set不可以插入重复数据，而multiset可以
- set插入数据的同时会返回插入结果，表示插入是否成功
- multiset不会检测数据，因此可以插入重复数据

示例：
```cpp
void test01()
{
	set<int> s;
	pair<set<int>::iterator, bool> ret = s.insert(10);
	if (ret.second)
	{
		cout << "第一次插入成功！" << endl;
	}
	else
	{
		cout << "第一次插入失败！" << endl;
	}

	ret = s.insert(10);
	if (ret.second)
	{
		cout << "第二次插入成功！" << endl;
	}
	else
	{
		cout << "第二次插入失败！" << endl;
	}

	multiset<int> ms;
	ms.insert(10);
	ms.insert(10);
}
```
>小结：  
如果不允许插入重复数据可以利用set  
如果需要插入重复数据利用multiset

### 3.8.7 pair对组创建
**功能描述**：成对出现的数据，利用对组可以返回两个数据  
**两种创建方式**：
- ```pair<type, type> p(value1, value2);```
- ```pair<type, type> p = make_pair(value1, value2);```

示例：
```cpp
void test01()
{
	pair<string, int> p(string("Tom"), 20);
	cout << p.first << p.second << endl;

	pair<string, int> p1 = make_pair("James", 33);
	cout << p1.first << p.second << endl;
}
```

### 3.8.8 set容器排序
学习目标：set容器默认排序规则为从小到大，掌握如何改变排序规则  
主要技术点：利用仿函数，可以改变排序规则  
**示例一** set存放内置数据类型
```cpp
class MyCompare
{
public :
	bool operator() (int v1, int v2) const
	{
		return v1 > v2;
	}
};

void test01()
{
	set<int, MyCompare> s1;
	s1.insert(2);
	s1.insert(7);
	s1.insert(3);
	s1.insert(4);
	s1.insert(5);

	for (set<int, MyCompare>::iterator it = s1.begin(); it != s1.end(); it++)
	{
		cout << *it << endl;
	}
}
```
>小结：  
利用仿函数可以指定set容器的排序规则

**示例二** set存放自定义数据类型
```cpp
class Person
{
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}

public:
	string name;
	int age;
};

class comaprePerson
{
public:
	bool operator () (const Person& p1, const Person& p2) const
	{
		return p1.age > p2.age;
	}
};

void test01()
{
	set<Person, comaprePerson> s;
	Person p1("刘", 23);
	Person p2("关", 33);
	Person p3("张", 43);
	Person p4("曹", 3);

	s.insert(p1);
	s.insert(p2);
	s.insert(p3);
	s.insert(p4);

	for (set<Person, comaprePerson>::iterator it = s.begin(); it != s.end(); it++)
	{
		cout << it->name << " " << it->age << endl;
	}
}
```
>小结：  
对于自定义数据类型，set必须指定排序规则才可以插入数据

## 3.9 map/multimap容器
### 3.9.1 map基本概念
**简介**：
- map中所有元素都是pair
- pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）
- 所有元素都会根据元素的键值自动排序

**本质**：
- map/multimap属于**关联式容器**，底层结构是用二叉树实现

**优点**：
- 可以根据key值快速找到value值

map和multimap**区别**：
- map不允许容器中有重复key值元素
- multimap允许容器中有重复key值元素

### 3.9.2 map构造和赋值
**功能描述**：
- 对map容器进行构造和赋值操作

**函数原型**：  
构造：
- ```map<T1, T2> map;``` map默认构造函数
- ```map(const map &mp);``` 拷贝构造函数

赋值：
- ```map& operator=(const map &mp);``` 重载等号操作符

**示例**：
```cpp
void printMap(map<int, int> m)
{
	for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
	{
		cout << it->first << " " << it->second << endl;
	}
}

void test01()
{
	map<int, int> m;
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(2, 20));
	m.insert(pair<int, int>(3, 30));
	m.insert(pair<int, int>(4, 40));
	printMap(m);

	map<int, int> m2(m);
	printMap(m2);

	map <int, int> m3;
	m3 = m2;
	printMap(m3);
}
```
>小结：  
map中所有元素都是成对出现的，插入数据时要使用对组pair

### 3.9.3 map大小和交换
**功能描述**：统计map容器大小以及交换map容器  
**函数原型**：
- ```size();``` 返回容器中元素的数目
- ```empty();``` 判断容器是否为空
- ```swap(st);``` 交换两个集合容器

示例：
```cpp
void test01()
{
	map<int, int> m;
	m.insert(pair<int, int>(1, 10));
	m.insert(pair<int, int>(2, 20));
	m.insert(pair<int, int>(3, 30));
	m.insert(pair<int, int>(4, 40));

	map<int, int> m1;
	m1.insert(pair<int, int>(3, 30));

	m.swap(m1);
	m1.swap(m);
	printMap(m);

	cout << m.size() << m.empty() << endl;
}
```

### 3.9.4 map插入和删除
**功能描述**：map容器进行插入数据和删除数据  
**函数原型**：
- ```insert(elem);``` 在容器中插入元素
- ```clear();``` 清除所有元素
- ```erase(pos);``` 删除pos迭代器所指的元素，返回下一个元素的迭代器
- ```erase(beg, end);``` 删除区间[beg, end)的所有元素，返回下一个元素的迭代器
- ```erase(key);``` 删除容器中值为key的元素

示例：
```cpp
void test01()
{
	map<int, int> m;
	m.insert(pair<int, int>(1, 10));
	m.insert(make_pair(2, 20));
	m.insert(map<int, int>::value_type(3, 30));
	m[4] = 40;

	printMap(m);

	m.erase(m.begin());
	m.erase(2);
	printMap(m);

	m.clear();
}
```

### 3.9.5 map查找和统计
**功能描述**：对map容器进行查找数据以及统计数据  
**函数原型**：
- ```find(key);``` 查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();
- ```count(key);``` 统计key的元素个数

示例：
```cpp
if (m.find(3) != m.end())
{
	cout << "找到了元素 key = 3"
}
m.count(3);
```

### 3.9.6 map容器排序
学习目标：
- map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则

主要技术点：
- 利用仿函数

示例：
```cpp
class MyCompare
{
public:
	bool operator () (int v1, int v2) const
	{
		return v1 > v2;
	}
};

void printMap(map<int, int, MyCompare> m)
{
	for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
	{
		cout << it->first << " " << it->second << endl;
	}
}

void test01()
{
	map<int, int, MyCompare> m;
	m.insert(pair<int, int>(1, 10));
	m.insert(make_pair(5, 50));
	m.insert(map<int, int>::value_type(3, 30));
	m[4] = 40;

	printMap(m); // 按键位倒序输出
}
```
>小结：  
当数据以键值对形式存在，可以考虑用map或multimap


# 四、STL - 函数对象
## 4.1 函数对象
### 4.1.1 函数对象概念
**概念**： 
- 重载**函数调用操作符**的类，其对象常称为函数对象
- **函数对象**使用重载的（）时，行为类似函数调用，也叫**仿函数**

**本质**：  
函数对象（仿函数）是一个**类**，而不是一个函数

### 4.1.2 函数对象使用
**特点**：  
- 函数对象在使用时，可以像普通函数对象那样调用，可以有参数，可以有返回值
- 函数对象超出普通函数的概念，函数对象可以有自己的状态
- 函数对象可以作为参数传递

示例：
```cpp
#include <iostream>
using namespace std;

// 1. 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
class MyAdd
{
public:
	int operator () (int a, int b)
	{
		return a + b;
	}
};

void test01()
{
	MyAdd myadd;
	cout << myadd(3, 4) << endl;
}

// 2. 函数对象可以有自己的状态
class MyPrint
{
public:
	MyPrint()
	{
		count = 0;
	}

	void operator () (string test)
	{
		cout << test << endl;
		count++;
	}

	int count;
};

void test02()
{
	MyPrint myPrint;
	myPrint("hello world");
	myPrint("hello world");
	myPrint("hello world");
	cout << "调用次数：" << myPrint.count << endl;
}

// 3. 函数对象可以作为参数传递
void doPrint(MyPrint& mp, string test)
{
	mp(test);
}

void test03()
{
	MyPrint mp;
	doPrint(mp, "hello");
}

int main()
{
	test01();
	test02();
	test03();

	system("pause");
	return 0;
}
```
>小结：  
仿函数写法非常灵活，可以作为参数进行传递

## 4.2 谓词
### 4.2.1 谓词概念
**概念**：
- 返回bool类型的仿函数称为**谓词**
- 如果operator()接受一个参数，那么叫做一元谓词
- 如果operator()接受两个参数，那么叫做二元谓词

### 4.2.2 一元谓词
示例：
```cpp
class MyCompare
{
public:
	bool operator () (int a)
	{
		return a > 5;
	}
};

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int>::iterator it = find_if(v.begin(), v.end(), MyCompare());
	cout << *it << endl;
}
```
>小结：  
参数只有一个的谓词，称为一元谓词

### 4.2.3 二元谓词
```cpp
class MyCompare
{
public:
	bool operator () (int a, int b)
	{
		return a > b;
	}
};

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	sort(v.begin(), v.end(), MyCompare());
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << *it << endl;
	}
}
```
>小结：  
参数只有两个的谓词，称为二元谓词

## 4.3 内建函数对象
### 4.3.1 内建函数对象意义
**概念**：
- STL内建了一些函数对象

**分类**:
- 算数仿函数
- 关系仿函数
- 逻辑仿函数

**用法**：
- 这些仿函数所产生的对象，用法和一般函数完全相同
- 使用内建函数对象，需要引入头文件```#include<functional>```

### 4.3.2 算术仿函数
**功能描述**：
- 实现四则运算
- 其中negate是一则运算，其他都是二元运算

**仿函数原型**：
- ```template<class T> T plus<T>``` 加法仿函数
- ```template<class T> T minus<T>``` 减法仿函数
- ```template<class T> T multiplies<T>``` 乘法仿函数
- ```template<class T> T divides<T>``` 除法仿函数
- ```template<class T> T modules<T>``` 取模仿函数
- ```template<class T> T negate<T>``` 取反仿函数

示例：
```cpp
#include <iostream>
using namespace std;
#include <functional>

void test01()
{
	negate<int> n;
	cout << n(50) << endl;

	plus<int> p;
	cout << p(30, n(20)) << endl;
}

int main()
{
	test01();
}
```

### 4.3.3 关系仿函数
**功能描述**：
- 实现关系对比

**仿函数原型**：
- ```template<class T> bool equal_to<T>``` 等于
- ```template<class T> bool not_equal_to<T>``` 不等于
- ```template<class T> bool greater<T>``` 大于 // 最常用
- ```template<class T> bool greater_equal<T>``` 大于等于
- ```template<class T> bool less<T>``` 小于
- ```template<class T> bool less_equal<T>``` 小于等于

示例：
```cpp
sort(v.begin(), v.end(), greater<int>());
```

### 4.3.4 逻辑仿函数
**功能描述**：
- 实现逻辑运算

**函数原型**：
- ```tmeplate<class T> bool logical_and<T>``` 逻辑与
- ```tempalce<class T> bool logical_or<T>``` 逻辑或
- ```templace<class T> bool logical_not<T>``` 逻辑非

示例：
```cpp
void test01()
{
	vector<int> v;
	v.push_back(true);
	v.push_back(false);
	v.push_back(true);
	v.push_back(false);

	vector<bool> v2;
	v2.resize(v.size());
	transform(v.begin(), v.end(), v2.begin(), logical_not<bool>());

	for (vector<bool>::iterator it = v2.begin(); it != v2.end(); it++)
	{
		cout << *it << endl;
	}
}
```
>小结：  
逻辑仿函数实际应用较少，了解即可


# 五、STL - 常用算法
**概述**：
- 算法主要是由头文件```<algorithm> <functional> <numeric>```组成
- ```<algorithm>```是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等
- ```<numeric>```体积很小，只包括几个在序列上面进行简单数学运算的模板函数
- ```<functional>```定义了一些模板类，用以声明函数对象

## 5.1 常用遍历算法
**学习目标**：
- 掌握常用的遍历算法

**算法简介**：
- ```for_each``` 遍历容器
- ```transform``` 搬运容器到另一个容器中

### 5.1.1 for_each
**功能描述**：
- 实现遍历容器

**函数原型**：
- ```for_each(iterator beg, iterator end, _func);```

示例：
```cpp
#include <iostream>
using namespace std;
#include <functional>
#include <vector>
#include <algorithm>

void print01(int val)
{
	cout << val << " ";
}

class print02
{
public:
	void operator () (int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	for_each(v.begin(), v.end(), print01);
	cout << endl;

	for_each(v.begin(), v.end(), print02());
	cout << endl;
}

int main()
{
	test01();
}
```

### 5.1.2 transform
**功能描述**：
- 搬运容器到另一个容器中

**函数原型**：
- ```transform(iterator beg1, iterator end1, iterator beg2, _func);```

示例：
```cpp
#include <iostream>
using namespace std;
#include <functional>
#include <vector>
#include <algorithm>

class Transform
{
public:
	int operator() (int val)
	{
		return val;
	}
};

class Print
{
public:
	void operator() (int val)
	{
		cout << val << " ";
	}
};

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int> vTarget;
	vTarget.resize(v.size());

	transform(v.begin(), v.end(), vTarget.begin(), Transform());
	for_each(vTarget.begin(), vTarget.end(), Print());
	cout << endl;
}

int main()
{
	test01();
}
```
>小结：搬运的目标容器必须要提前开辟空间，否则无法正常搬运

## 5.2 常用查找算法
**学习目标**：
- 掌握常用的查找算法

**算法简介**：
- ```find``` 查找元素
- ```find_if``` 按条件查找元素
- ```adjacent_find``` 查找相邻重复元素
- ```binary_search``` 二分查找法
- ```count``` 统计元素个数
- ```count_if``` 按条件统计元素个数

### 5.2.1 find
**功能描述**：
- 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()

**函数原型**：
- ```find(iterator beg, iterator end, value);``` 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

**示例**：
```cpp
void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int>::iterator it = find(v.begin(), v.end(), 5);
	if (it != v.end())
	{
		cout << "找到了" << endl;
	}
	else
	{
		cout << "没有找到" << endl;
	}
}

class Person
{
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}

	bool operator==(const Person& p) // 用find找自定义类型数据时要重载运算符
	{
		if (this->name == p.name && this->age == p.age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

public:
	string name;
	int age;
};

void test02()
{
	Person p1("aaa",  3);
	Person p2("李四",  4);
	Person p3("王五", 5);
	
	vector<Person> v;
	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);

	vector<Person>::iterator it = find(v.begin(), v.end(), Person("王五", 5));
	if (it == v.end())
	{
		cout << "没找到" << endl;
	}
	else
	{
		cout << it->name << it->age << endl;
	}
}
```

### 5.2.2 find_if
**功能描述**：
- 按条件查找元素

**函数原型**：
- ```find_if(iterator beg, iterator end, _Pred);```

示例：
```cpp
class Greater5
{
public:
	bool operator() (int val)
	{
		return val > 5;
	}
};

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int>::iterator it = find_if(v.begin(), v.end(), Greater5());
	if (it != v.end())
	{
		cout << "找到了" << *it << endl;
	}
	else
	{
		cout << "没有找到" << endl;
	}
}

class Person
{
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}

	bool operator==(const Person& p)
	{
		if (this->name == p.name && this->age == p.age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

public:
	string name;
	int age;
};

class Greater4
{
public:
	bool operator () (const Person &p)
	{
		return p.age > 4;
	}
};

void test02()
{
	Person p1("aaa",  3);
	Person p2("李四",  7);
	Person p3("王五", 5);
	
	vector<Person> v;
	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);

	vector<Person>::iterator it = find_if(v.begin(), v.end(), Greater4());
	if (it == v.end())
	{
		cout << "没找到" << endl;
	}
	else
	{
		cout << it->name << it->age << endl; // 李四7
	}
}
```

### 5.2.3 adjacent_find
**功能描述**：
- 查找相邻重复元素

**函数原型**：
- ```adjacent_find(iterator beg, iterator end);``` 查找相邻重复元素，返回相邻元素的第一个位置的迭代器

示例：
```cpp
void test01()
{
	vector<int> v;

	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(2);
	v.push_back(4);
	v.push_back(4);
	v.push_back(3);

	vector<int>::iterator it = adjacent_find(v.begin(), v.end());
	if (it == v.end())
	{
		cout << "找不到！" << endl;
	}
	else
	{
		cout << "找到：" << *it << endl;
	}
}
```

### 5.2.4 binary_search
**功能描述**：
- 查找指定元素是否存在

**函数原型**：
- ```bool binary_search(iterator beg, iterator end, value);``` 查到指定的元素，查到返回true，否则false；在**无序序列中不可用**

示例：
```cpp
void test01()
{
	vector<int> v;

	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	bool ret = binary_search(v.begin(), v.end(), 2);
	if (ret)
	{
		cout << "找到了" << endl;
	}
	else
	{
		cout << "未找到" << endl;
	}
}
```
>小结：  
二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列

### 5.2.5 count
**功能描述**：
- 统计元素个数

**函数原型**：
- ```count(iterator beg, iterator end, value);``` 统计元素出现次数

示例：
```cpp
void test01()
{
	vector<int> v;
	
	v.push_back(1);
	v.push_back(3);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);
	v.push_back(3);
	v.push_back(4);

	int num = count(v.begin(), v.end(), 4);
	cout << "找到的个数是：" << num << endl;
}
// 自定义数据类型同find
```

### 5.2.6 count_if
**功能描述**：
- 按条件统计元素个数

**函数原型**：
- ```count_if(iterator beg, iterator end, _Pred);``` 按条件统计元素出现次数

示例：
```cpp
class Greater3
{
public:
	bool operator() (int val)
	{
		return val > 3;
	}
};

void test01()
{
	vector<int> v;
	
	v.push_back(1);
	v.push_back(3);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);
	v.push_back(4);
	v.push_back(3);
	v.push_back(4);

	int num = count_if(v.begin(), v.end(), Greater3());
	cout << "找到的个数是：" << num << endl;
}
```

## 5.3 常用排序算法
**学习目标**：
- 掌握常用的排序算法

**算法简介**：
- ```sort``` 对容器内元素进行排序
- ```random_shuffle``` 洗牌 指定范围内的元素随机调整次序
- ```merge``` 容器元素合并，并存储到另一容器中
- ```reverse``` 反转指定范围的元素

### 5.3.1 sort
- ```sort(iterator beg, iterator end, _Pred);``` 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

示例：
```cpp
class myPrint
{
public:
	void operator() (int val)
	{
		cout << val << endl;
	}
};

void test01()
{
	vector<int> v;

	v.push_back(10);
	v.push_back(30);
	v.push_back(20);
	v.push_back(50);
	v.push_back(40);

	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(), myPrint());

	sort(v.begin(), v.end(), greater<int>());
	for_each(v.begin(), v.end(), myPrint());
}
```

### 5.3.2 random_shuffle
**功能描述**：
- 洗牌 指定范围内的元素随机调整次序

**函数原型**：
- ```random_shuffle(iterator beg, iterator end);``` 指定范围内的元素随即调整次序

示例：
```cpp
void test01()
{
	srand((unsigned int)time(NULL)); // 一定要添加随机数种子

	vector<int> v;

	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	random_shuffle(v.begin(), v.end());

	for_each(v.begin(), v.end(), MyPrint());
}
```

### 5.3.3 merge
**功能描述**：
- 两个容器元素合并，并存储到另一容器中

**函数原型**：
- ```merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);``` 容器元素合并，并存储到另一个容器中；两个容器**必须是有序的**

示例：
```cpp
void test01()
{
	vector<int> v1, v2;
	for (int i = 10; i > 0; i--)
	{
		v1.push_back(i);
		v2.push_back(i - 1);
	}

	vector<int> vTarget;
	vTarget.resize(v1.size() + v2.size());
	
	merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin(), greater<int>()); // 降序需要谓词
	for_each(vTarget.begin(), vTarget.end(), MyPrint());
}
```

### 5.3.4 reverse
**功能描述**：
- 将容器内元素进行反转

**函数原型**：
- ```reverse(iterator beg, iterator end);``` 反转指定范围的元素

示例：
```cpp
void test01()
{
	vector<int> v;
	v.push_back(20);
	v.push_back(10);
	v.push_back(50);
	v.push_back(30);
	v.push_back(40);

	reverse(v.begin(), v.end());
	for_each(v.begin(), v.end(), MyPrint());
}
```

## 5.4 常用拷贝和替换算法
**学习目标**：
- 掌握常用的拷贝和替换算法

**算法简介**：
- ```copy``` 容器内指定范围的元素拷贝到另一容器中
- ```replace``` 将容器内指定范围的旧元素修改为新元素
- ```replace_if``` 容器内指定范围满足条件的元素替换为新元素
- ```swap``` 互换两个容器的元素

### 5.4.1 copy
**功能描述**：
- 容器内指定范围的元素拷贝到另一容器中

**函数原型**：
- ```copy(iterator beg, iterator end, iterator dest);``` 按值查找元素，找到返回指定位置迭代器，找不到返回结束位置迭代器

示例：
```cpp
void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int> v2;
	v2.resize(v.size());
	copy(v.begin(), v.end(), v2.begin());

	for_each(v2.begin(), v2.end(), MyPrint());
}
```
>小结：  
利用copy算法在拷贝时，目标容器记得提前开辟空间

### 5.4.2 replace
**功能描述**：
- 将容器内指定范围的旧元素修改为新元素

**函数原型**：
- ```replace(iterator beg, iterator, end, oldvalue, newvalue);``` 将区间内旧元素 替换成 新元素

示例：
```cpp
void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	replace(v.begin(), v.end(), 3, 3000);

	for_each(v.begin(), v.end(), MyPrint());
}
```

### 5.4.3 replace_if
**功能描述**：
- 将区间内满足条件的元素，替换成指定元素

**函数原型**：
- ```replace_if(iterator beg, iterator end, _pred, newvalue);``` 按条件替换元素，满足条件的替换成指定元素

示例：
```cpp
class Greater3
{
public:
	bool operator () (int val)
	{
		return val > 3;
	}
};

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	replace_if(v.begin(), v.end(), Greater3(), 3000);

	for_each(v.begin(), v.end(), MyPrint());
}
```

### 5.4.4 swap
**功能描述**：
- 互换两个容器的元素

**函数原型**：
- ```swap(container c1, container c2);``` 互换两个容器的元素

示例：
```cpp
void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	vector<int> v2;
	v2.resize(v.size());
	copy(v.begin(), v.end(), v2.begin());

	replace_if(v.begin(), v.end(), Greater3(), 3000);

	swap(v, v2);

	for_each(v.begin(), v.end(), MyPrint());
}
```

## 5.5 常用算术生成算法
**学习目标**：
- 掌握常用的算术生成算法

**注意**：
- 算术生成算法属于小型算法，使用时包含的头文件为```#include <numeric>```

**算法简介**：
- ```accumulate``` 计算容器元素累计综合
- ```fill``` 像容器中添加元素

## 5.5.1 accumulate
**功能描述**：
- 计算区间内 容器元素累计总和

**函数原型**
- ```accumulate(iterator beg, iterator end, value);``` 计算容器元素累计总和；value为起始值

示例：
```cpp
void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	int sum = accumulate(v.begin(), v.end(), 0);

	cout << sum << endl; // 45

	int sum2 = accumulate(v.begin(), v.end(), 10);

	cout << sum2 << endl; // 55
}
```
>小结：  
accumulate使用时头文件注意是numeric，这个算法很实用

### 5.5.2 fill
**功能描述**：
- 像容器中填充指定的元素

**函数原型**：
- ```fill(iterator beg, iterator end, value);``` 像容器中填充元素

示例：
```cpp
void test01()
{
	vector<int> v;
	v.resize(10);

	fill(v.begin(), v.end(), 100);

	for_each(v.begin(), v.end(), MyPrint());
}
```

## 5.6 常用集合算法
**学习目标**：
- 掌握常用的集合算法

**算法简介**：
- ```set_intersection``` 求两个容器的交集
- ```set_union``` 求两个容器的并集
- ```set_difference``` 求两个容器的差集

### 5.6.1 set_intersection
**功能描述**：
- 求两个容器的交集

**函数原型**：
- ```set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);``` 求两个集合的交集，两个集合必须是有序序列

示例：
```cpp
void test01()
{
	vector<int> v1, v2;
	
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
		v2.push_back(i + 5);
	}

	vector<int> vTarget;
	vTarget.resize(min(v1.size(), v2.size()));

	vector<int>::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, MyPrint());
}
```
>小结：   
求交集的两个集合必须是有序序列  
目标容器开辟空间需要从**两个容器中取小值**  
set_intersection返回值即是交集中**最后一个**元素的位置

## 5.6.2 set_union
**功能描述**：
- 求两个集合的并集

**函数原型**：
- ```set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);``` 求两个集合的并集，两个集合必须是有序序列

示例：
```cpp
void test01()
{
	vector<int> v1, v2;
	
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
		v2.push_back(i + 5);
	}

	vector<int> vTarget;
	vTarget.resize(v1.size() + v2.size()); // 注意空间分配

	vector<int>::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, MyPrint());
}
```
>小结：  
求并集的两个集合必须是有序序列  
目标容器开辟空间需要**两个容器相加**  
set_union返回值即是并集中最后一个元素的位置

## 5.6.3 set_difference
**功能描述**：
- 求两个集合的差集

**函数原型**：
- ```set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)``` 求两个集合的差集，两个集合必须是有序序列

示例
```cpp
void test01()
{
	vector<int> v1, v2;
	
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
		v2.push_back(i + 5);
	}

	vector<int> vTarget;
	vTarget.resize(max(v1.size(), v2.size()));

	vector<int>::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, MyPrint());

	// v1和v2的差集 与 v2和v1的差集不同
	itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, MyPrint());
}
```
>小结：  
求差集的两个集合必须是有序序列  
目标容器开辟空间需要从**两个容器取大值**  
set_difference返回值即是差集中最后一个元素的位置

