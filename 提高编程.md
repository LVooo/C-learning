# C++learning
[toc]

本阶段主要针对C++**泛型编程**和**STL**技术做详细讲解，探讨cpp更深层的使用
# 一、模板
## 1.1 模板的概念
模板就是建立**通用的摸具**，大大提高**复用性**  
模板的特点： 
- 模板不可以直接使用，它只是一个框架
- 模板的通用并不是万能的

## 1.2 函数模板
- C++另一种编程思想称为**泛型编程**，主要利用的技术就是模板
- C++提供两种模板机制：**函数模板**和**类模板**
### 1.2.1 函数模板用法
函数模板作用：  
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。  
**语法**：
```cpp
template<typename T> 
函数声明或定义
```
**解释**：  
template —— 声明创建模板  
typename —— 表明其后面的符号是一种数据类型，可以用class代替  
T —— 通用的数据类型，名称可以替换，通常为大写字母  
**示例**：  
```cpp
#include <iostream>
using namespace std;

template <typename T>
void mySwap(T a, T b)
{
	T temp = a;
	a = b;
	b = temp;
}


void test01()
{
	char a = 'a', b = 'b';
	// 1. 自动类型推导
	//mySwap(a, b);
	//cout << "a=" << a << " " << "b=" << b << endl;

	// 2. 显示指定类型
	mySwap<int>(a, b);
	cout << "a=" << a << " " << "b=" << b << endl;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
函数模板利用关键字template  
使用函数模板有两种方式：自动类型推导、显示指定类型  
模板的目的是为了提高复用性，将类型参数化

### 1.2.2 函数模板注意事项
注意事项：  
- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用  
示例：
```cpp
template<class T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

// 1. 自动类型推导，必须推导出一致的数据类型T，才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	mySwap(a, b); // 正确，可以推导出一致的T
	//mySwap(a, c); // 错误，推到不出一致的T类型
}

// 2. 模板必须要确定出T的数据类型，才可以使用
template<class T>
void func()
{
	cout << "func 的调用" << endl;
}

void test02()
{
	//func(); // 错误，模板不能独立使用，必须确定出T的类型
	func<int>(); // 利用显示指定类型的方式，给T一个类型，才可以使用该模板
}

int main()
{
	test01();
	test02();

	system("pause");
	return 0;
}
```
>小结：  
使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型

### 1.2.3 函数模板案例
案例描述：
- 利用函数模板封装一个排序的函数，可以对**不同数据类型数组进行**排序
- 排序规则为从大到小，排序算法为**选择排序**
- 分别利用**char数组**和**int数组**进行测试  
示例：
```cpp
template <class T>
void mySort(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		int max = i;
		for (int j = i + 1; j < len; j++)
		{
			if (arr[j] > arr[max])
			{
				max = j;
			}
		}
		if (max != i) // swap;
		{
			int tmp = arr[i];
			arr[i] = arr[max];
			arr[max] = tmp;
		}
	}
}

template <class T>
void printRes(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}

void test01()
{
	char charArr[] = "asdasdasd";
	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);
	printRes(charArr, num);
}

```
>小结：  
模板可以提高代码复用，需要熟练掌握

### 1.2.4 普通函数与函数模板的区别
**区别：**
- 普通函数调用时可以发生自动类型转换（隐式类型转换）
- 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
- 如果利用显示指定类型的方式，可以发生隐式类型转换
**示例：**
```cpp
template<class T>
T myAdd(T a, T b)
{
	return a + b;
}
// 在普通函数里是可以数字加上字符类型的，字符会转换成对应ASCII码
// 但是在函数模板中不可以发生自动类型转换，需要使用显示指定类型才可以发生隐式类型转换：
myAdd<int>(a, c);
```
>小结：  
建议使用显式指定类型的方式，调用函数模板，因为可以自己确定通用类型T

### 1.2.5 普通函数与函数模板的调用规则
调用规则如下：
1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载：```myPrint<>(a, b)```
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

>小结：  
既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

### 1.2.6 模板的局限性
局限性：
- 模板的通用性并不是万能的

例如：
```cpp
template<class T>
void f(T a, T b)
{
	a = b;
}
```
在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了  
再例如：
```cpp
template<class T>
void f(T a, T b)
{
	if (a > b) {...}
}
```
在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行  
因此cpp为了解决这种问题，提供模板的**重载**，可以为这些特定的类型提供**具体化**的模板  
示例：
```cpp
template <class T>
bool myCompare(T a, T b)
{
	if (a = b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

// 具体化，以template<>开头，并通过名称来指出类型
// 具体化优先于常规模板
template<> bool myCompare(Person& p1, Person& p2)
{
	if (p1, name == p2.name ......)
		....
}
```
>小结：  
利用具体化的模板，可以解决自定义类型的通用化  
学习模板并不是为了写模板，而是在STL能够运用系统提供的模板


## 1.3 类模板
### 1.3.1 类模板语法
类模板作用：
- 建立一个通用类，类中的成员 数据类型可以不具体指定，用一个**虚拟的类型**来代表。

语法：
```cpp
template<class T>
类
```
解释：  
template —— 声明创建模板  
typename/class —— 表明其后面的符号是一种数据类型，可以用class代替  
T —— 通用的数据类型，名称可以替换，通常为大写字母  
示例：
```cpp
#include <iostream>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->name = name;
		this->age = age;
	}
	void showPerson()
	{
		cout << "Name : " << name << " Age: " << age << endl;
	}

public:
	NameType name;
	AgeType age;
};


void test01()
{
	// 类模板使用只能用显示指定类型方式
	Person<string, int> p("美猴王", 33);
	p.showPerson();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板

### 1.3.2 类模板与函数模板区别
类模板与函数模板区别主要有两点：
1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

示例：
```cpp
Person<string, int> p("美猴王", 33); // 1. 
template<class NameType, class AgeType = int>
Person<string> p("美猴王"); // 2.
```

### 1.3.3 类模板中成员函数创建时机
类模板中成员函数和普通类中成员函数创建时机是有区别的：
- 普通类中的成员函数一开始就可以创建
- 类模板中的成员函数在调用时创建

示例：
```cpp
class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show" << endl;
	}
};

class MyClass2
{
public:
	void func()
	{
		obj.showPerson1(); // 需指定数据类型才可调用
	}

public:
	Person1 obj;
};

template<class T>
class MyClass
{
public:
	T obj;

	// 类模板中的成员函数，并不是在一开始就创建的，而是在模板调用时再生成
	void func1() { obj.showPerson1(); }
	void func2() { obj.showPerson2(); }
};


void test01()
{
	MyClass<Person1> m;
	m.func1();
	//m.func2(); // 编译出错，说明函数调用才会去创建成员函数
}
```
>小结：  
类模板中的成员函数并不是一开始就创建的，在调用时才去创建

### 1.3.4 类模板对象做函数参数
类模板实例化出的对象，向函数传参的方式   
一共有三种传入方式：
1. 指定传入的类型 —— 直接显示对象的数据类型
2. 参数模板化 —— 将对象中的参数变为模板进行传递
3. 整个类模板化 —— 将这个对象类型 模板化进行传递

示例：
```cpp
// 1.指定传入类型
void func1(Person<string, int> &p)
{
	...
}

// 2.参数模板化
template<class T1, class T2>
void func2(Person<T1, T2> &p)
{
	...
}

// 3.整个类模板化
template<class T>
void func3(T &p)
{
	...
}

void test()
{
	Person <string, int> p("猪猪侠", 18);
	func123(p);
}
```
>小结：  
通过类模板创建的对象，可以有三种方式向函数中进行传参  
使用比较广泛的是第一种：指定传入的类型

### 1.3.5 类模板与继承
当类模板碰到继承时，需要注意以下几点：
- 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
- 如果不指定，编译器无法给子类分配内存
- 如果想灵活指定出父类中T的类型，子类也需要变为类模板

示例：
```cpp
template<class T>
class Base
{
public:
	T m;
};

//class Son :public Base // 错误，cpp编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son : public Base<int>
{
public:
	Son(int m)
	{
		this->m = m;
		cout << this->m << endl;
	}
};

// 类模板继承类模板，可以用T2指定父类中的T类型
template<class T1, class T2>
class Son2 : public Base<T2>
{
public:
	Son2()
	{
		cout << typeid(T1).name() << endl;
		cout << typeid(T2).name() << endl;
	}
};


void test01()
{
	Son s(3);
	Son2<int, char> s2;
}
```
>小结：  
如果父类是类模板，子类需要指定出父类中T的数据类型

### 1.3.6 类模板成员函数类外实现
示例：
```cpp
// 构造成员函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) 
{
	...
}

// 成员函数 类外实现
template<class T1, class T2> 
void Person<T1, T2>::showPerson() // 注意<>的位置
{
	...
}
```
>小结：  
类模板中成员函数类外实现时，需要加上模板参数列表

### 1.3.7 类模板 分文件编写
掌握类模板成员函数分文件编写产生的问题以及解决方式  
问题：
- 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决：
- 方法1：直接包含.cpp源文件
- 方法2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

示例：  
person.hpp
```cpp
#pragma once
#include <iostream>
using namespace std;

template <class T1, class T2>
class Person
{
public:
	Person(T1 name, T2 age);
	void showPerson();

public:
	T1 name;
	T2 age;
};

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->name = name;
	this->age = age;
}

template <class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "Name :" << this->name << " Age:" << age << endl;
}
```
main.cpp
```cpp
//#include "person.cpp" // 解决方式1，包含cpp
#include "person.hpp" // 解决方式2，将声明和实现写在一起，文件后缀名改为.hpp

void test01()
{
	Person<string, int> p("张三", 13);
	p.showPerson();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp

### 1.3.8 类模板与友元
掌握类模板配合友元函数的类内和类外实现  
全局函数类内实现 —— 直接在类内声明友元即可  
全局函数类外实现 —— 需要提前让编译器知道全局函数的存在  
示例：
```cpp
// 2. 全局函数配合友元 类外实现 —— 先做函数模板声明，下方再做函数模板定义，再做友元
template<class T1, class T2> class Person;

// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
template<class T1, class T2>
void printPerson2(Person<T1, T2>& p)
{
	
}

template<class T1, class T2>
class Person
{
	// 1. 全局函数配合友元 类内实现
	friend void printPerson(Person<T1, T2>& p)
	{
		...
	}

	// 2. 全局函数配合友元 类外实现
	friend void printPerson2<>(Person<T1, T2>& p);

private:
	T1 name;
	T2 age;
};
```
>小结：  
建议全局函数做类内实现，用法简单，而且编译器可以直接识别

### 1.3.9 类模板案例
案例描述：实现一个通用的数组类，要求如下：
- 可以对内置数据类型以及自定义数据类型的数据进行存储
- 将数组中的数据存储到堆区
- 构造函数中可以传入数组的容量
- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
- 提供尾插法和尾删法对数组中的数据进行增加和删除
- 可以通过下标的方式访问数组中的元素
- 可以获取数组中当前元素个数和数组的容量

示例：  
myArray.hpp
```cpp
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
	// 构造函数
	MyArray(int capacity)
	{
		this->m_Capacity = capacity;
		this->m_Size = 0;
		pAddress = new T[this->m_Capacity];
	}

	// 拷贝构造
	MyArray(const MyArray& arr)
	{
		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			// 如果T为对象，而且还包含指针，必须需要重载=操作符，因为这个等号不是构造而是赋值
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	// 重载 = 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& arr)
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}

		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	// 重载[] 操作符 arr[0]
	T& operator [](int index)
	{
		return this->pAddress[index];
	}

	// 尾插法
	void Push_back(const T& val)
	{
		if (this->m_Capacity == this->m_Size)
		{
			return;
		}
		this->pAddress[this->m_Size] = val;
		this->m_Size++;
	}

	// 尾删法
	void Pop_back()
	{
		if (this->m_Size == 0)
		{
			return;
		}
		this->m_Size--;
	}

	// 获取数组容量
	int getCapacity()
	{
		return this->m_Capacity;
	}

	// 获取数组大小
	int getSize()
	{
		return this->m_Size;
	}

	// 析构
	~MyArray()
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->pAddress = NULL;
			this->m_Size = 0;
			this->m_Capacity = 0;
		}
	}

private:
	T* pAddress; // 指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; // 容量
	int m_Size; // 大小
};
```
main.cpp测试：
```cpp
#include "MyArray.hpp"

void test01()
{
	MyArray<int> a1(10); // 可初始化各种数据类型，包括自定义数据类型
	for (int i = 0; i < 10; i++)
	{
		a1.Push_back(i);
		cout << a1[i] << endl;
	}
	cout << a1.getSize() << endl;
	
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
利用所学知识点实现通用的数组


# 二、STL初始
## 2.1 STL的诞生
- 长久以来，软件界一直希望建立一种可重复利用的东西
- cpp的**面向对象**和**泛型编程**思想，目的就是**复用性的提升**
- 大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
- 为了建立数据结构和算法的一套标准，诞生了**STL**

## 2.2 STL基本概念
- STL（Standard Template Library，标准模板库）
- STL从广义上分为：容器 算法 迭代器
- **容器**和**算法**之间通过**迭代器**进行无缝连接
- STL几乎所有的代码都采用了模板类或者模板函数

## 2.3 STL六大组件
STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
1. 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂
4. 仿函数：行为类似函数，可作为算法的某种策略
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西
6. 空间适配器：负责空间的配置和管理

## 2.4 STL中容器、算法、迭代器
**STL容器**：置物之所也；将运用最广泛的一些数据结构实现出来  
常用的数据结构：数组、链表、树、栈、队列、集合、映射表等   
这些容器分为**序列式容器**和**关联式容器**两种：  
序列式：强调值得排序，序列式容器中的每个元素均有固定的位置
关联式：二叉树结构，各元素之间没有严格的物理上的顺序关系

**算法**：问题之解法也；有限的步骤解决逻辑或数学上的问题  
算法分为：**质变算法**和**非质变算法**：  
质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝、替换、删除等等  
非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等  

**迭代器**：容器和算法之间粘合剂；提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。  
每个容器都有自己专属的迭代器  
迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针  
迭代器种类：  
1. 输入迭代器：只读 ++ ==
2. 输出迭代器：只写 ++
3. 前向迭代器：读写 ++ ==
4. 双向迭代器：读写 ++ --
5. 随机访问迭代器：读写，跳跃访问 +5 [n] >=

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器

## 2.5 容器算法迭代器初识
了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力  
STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器
### 2.5.1 vector存放内置数据类型
容器：```vector```  
算法：```for_each```  
迭代器：```vector<int>::iterator```  
示例：
```cpp
