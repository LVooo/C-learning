# C++learning
[toc]

本阶段主要针对C++**泛型编程**和**STL**技术做详细讲解，探讨cpp更深层的使用
# 一、模板
## 1.1 模板的概念
模板就是建立**通用的摸具**，大大提高**复用性**  
模板的特点： 
- 模板不可以直接使用，它只是一个框架
- 模板的通用并不是万能的

## 1.2 函数模板
- C++另一种编程思想称为**泛型编程**，主要利用的技术就是模板
- C++提供两种模板机制：**函数模板**和**类模板**
### 1.2.1 函数模板用法
函数模板作用：  
建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。  
**语法**：
```cpp
template<typename T> 
函数声明或定义
```
**解释**：  
template —— 声明创建模板  
typename —— 表明其后面的符号是一种数据类型，可以用class代替  
T —— 通用的数据类型，名称可以替换，通常为大写字母  
**示例**：  
```cpp
#include <iostream>
using namespace std;

template <typename T>
void mySwap(T a, T b)
{
	T temp = a;
	a = b;
	b = temp;
}


void test01()
{
	char a = 'a', b = 'b';
	// 1. 自动类型推导
	//mySwap(a, b);
	//cout << "a=" << a << " " << "b=" << b << endl;

	// 2. 显示指定类型
	mySwap<int>(a, b);
	cout << "a=" << a << " " << "b=" << b << endl;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
函数模板利用关键字template  
使用函数模板有两种方式：自动类型推导、显示指定类型  
模板的目的是为了提高复用性，将类型参数化

### 1.2.2 函数模板注意事项
注意事项：  
- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用  
示例：
```cpp
template<class T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

// 1. 自动类型推导，必须推导出一致的数据类型T，才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	mySwap(a, b); // 正确，可以推导出一致的T
	//mySwap(a, c); // 错误，推到不出一致的T类型
}

// 2. 模板必须要确定出T的数据类型，才可以使用
template<class T>
void func()
{
	cout << "func 的调用" << endl;
}

void test02()
{
	//func(); // 错误，模板不能独立使用，必须确定出T的类型
	func<int>(); // 利用显示指定类型的方式，给T一个类型，才可以使用该模板
}

int main()
{
	test01();
	test02();

	system("pause");
	return 0;
}
```
>小结：  
使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型

### 1.2.3 函数模板案例
案例描述：
- 利用函数模板封装一个排序的函数，可以对**不同数据类型数组进行**排序
- 排序规则为从大到小，排序算法为**选择排序**
- 分别利用**char数组**和**int数组**进行测试  
示例：
```cpp
template <class T>
void mySort(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		int max = i;
		for (int j = i + 1; j < len; j++)
		{
			if (arr[j] > arr[max])
			{
				max = j;
			}
		}
		if (max != i) // swap;
		{
			int tmp = arr[i];
			arr[i] = arr[max];
			arr[max] = tmp;
		}
	}
}

template <class T>
void printRes(T arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}

void test01()
{
	char charArr[] = "asdasdasd";
	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);
	printRes(charArr, num);
}

```
>小结：  
模板可以提高代码复用，需要熟练掌握

### 1.2.4 普通函数与函数模板的区别
**区别：**
- 普通函数调用时可以发生自动类型转换（隐式类型转换）
- 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
- 如果利用显示指定类型的方式，可以发生隐式类型转换
**示例：**
```cpp
template<class T>
T myAdd(T a, T b)
{
	return a + b;
}
// 在普通函数里是可以数字加上字符类型的，字符会转换成对应ASCII码
// 但是在函数模板中不可以发生自动类型转换，需要使用显示指定类型才可以发生隐式类型转换：
myAdd<int>(a, c);
```
>小结：  
建议使用显式指定类型的方式，调用函数模板，因为可以自己确定通用类型T

### 1.2.5 普通函数与函数模板的调用规则
调用规则如下：
1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载：```myPrint<>(a, b)```
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

>小结：  
既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

### 1.2.6 模板的局限性
局限性：
- 模板的通用性并不是万能的

例如：
```cpp
template<class T>
void f(T a, T b)
{
	a = b;
}
```
在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了  
再例如：
```cpp
template<class T>
void f(T a, T b)
{
	if (a > b) {...}
}
```
在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行  
因此cpp为了解决这种问题，提供模板的**重载**，可以为这些特定的类型提供**具体化**的模板  
示例：
```cpp
template <class T>
bool myCompare(T a, T b)
{
	if (a = b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

// 具体化，以template<>开头，并通过名称来指出类型
// 具体化优先于常规模板
template<> bool myCompare(Person& p1, Person& p2)
{
	if (p1, name == p2.name ......)
		....
}
```
>小结：  
利用具体化的模板，可以解决自定义类型的通用化  
学习模板并不是为了写模板，而是在STL能够运用系统提供的模板


## 1.3 类模板
### 1.3.1 类模板语法
类模板作用：
- 建立一个通用类，类中的成员 数据类型可以不具体指定，用一个**虚拟的类型**来代表。

语法：
```cpp
template<class T>
类
```
解释：  
template —— 声明创建模板  
typename/class —— 表明其后面的符号是一种数据类型，可以用class代替  
T —— 通用的数据类型，名称可以替换，通常为大写字母  
示例：
```cpp
#include <iostream>
using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->name = name;
		this->age = age;
	}
	void showPerson()
	{
		cout << "Name : " << name << " Age: " << age << endl;
	}

public:
	NameType name;
	AgeType age;
};


void test01()
{
	// 类模板使用只能用显示指定类型方式
	Person<string, int> p("美猴王", 33);
	p.showPerson();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板

### 1.3.2 类模板与函数模板区别
类模板与函数模板区别主要有两点：
1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

示例：
```cpp
Person<string, int> p("美猴王", 33); // 1. 
template<class NameType, class AgeType = int>
Person<string> p("美猴王"); // 2.
```

### 1.3.3 类模板中成员函数创建时机
类模板中成员函数和普通类中成员函数创建时机是有区别的：
- 普通类中的成员函数一开始就可以创建
- 类模板中的成员函数在调用时创建

示例：
```cpp
class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show" << endl;
	}
};

class MyClass2
{
public:
	void func()
	{
		obj.showPerson1(); // 需指定数据类型才可调用
	}

public:
	Person1 obj;
};

template<class T>
class MyClass
{
public:
	T obj;

	// 类模板中的成员函数，并不是在一开始就创建的，而是在模板调用时再生成
	void func1() { obj.showPerson1(); }
	void func2() { obj.showPerson2(); }
};


void test01()
{
	MyClass<Person1> m;
	m.func1();
	//m.func2(); // 编译出错，说明函数调用才会去创建成员函数
}
```
>小结：  
类模板中的成员函数并不是一开始就创建的，在调用时才去创建

### 1.3.4 类模板对象做函数参数
类模板实例化出的对象，向函数传参的方式   
一共有三种传入方式：
1. 指定传入的类型 —— 直接显示对象的数据类型
2. 参数模板化 —— 将对象中的参数变为模板进行传递
3. 整个类模板化 —— 将这个对象类型 模板化进行传递

示例：
```cpp
// 1.指定传入类型
void func1(Person<string, int> &p)
{
	...
}

// 2.参数模板化
template<class T1, class T2>
void func2(Person<T1, T2> &p)
{
	...
}

// 3.整个类模板化
template<class T>
void func3(T &p)
{
	...
}

void test()
{
	Person <string, int> p("猪猪侠", 18);
	func123(p);
}
```
>小结：  
通过类模板创建的对象，可以有三种方式向函数中进行传参  
使用比较广泛的是第一种：指定传入的类型

### 1.3.5 类模板与继承
当类模板碰到继承时，需要注意以下几点：
- 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
- 如果不指定，编译器无法给子类分配内存
- 如果想灵活指定出父类中T的类型，子类也需要变为类模板

示例：
```cpp
template<class T>
class Base
{
public:
	T m;
};

//class Son :public Base // 错误，cpp编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son : public Base<int>
{
public:
	Son(int m)
	{
		this->m = m;
		cout << this->m << endl;
	}
};

// 类模板继承类模板，可以用T2指定父类中的T类型
template<class T1, class T2>
class Son2 : public Base<T2>
{
public:
	Son2()
	{
		cout << typeid(T1).name() << endl;
		cout << typeid(T2).name() << endl;
	}
};


void test01()
{
	Son s(3);
	Son2<int, char> s2;
}
```
>小结：  
如果父类是类模板，子类需要指定出父类中T的数据类型

### 1.3.6 类模板成员函数类外实现
示例：
```cpp
// 构造成员函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) 
{
	...
}

// 成员函数 类外实现
template<class T1, class T2> 
void Person<T1, T2>::showPerson() // 注意<>的位置
{
	...
}
```
>小结：  
类模板中成员函数类外实现时，需要加上模板参数列表

### 1.3.7 类模板 分文件编写
掌握类模板成员函数分文件编写产生的问题以及解决方式  
问题：
- 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

解决：
- 方法1：直接包含.cpp源文件
- 方法2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

示例：  
person.hpp
```cpp
#pragma once
#include <iostream>
using namespace std;

template <class T1, class T2>
class Person
{
public:
	Person(T1 name, T2 age);
	void showPerson();

public:
	T1 name;
	T2 age;
};

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->name = name;
	this->age = age;
}

template <class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "Name :" << this->name << " Age:" << age << endl;
}
```
main.cpp
```cpp
//#include "person.cpp" // 解决方式1，包含cpp
#include "person.hpp" // 解决方式2，将声明和实现写在一起，文件后缀名改为.hpp

void test01()
{
	Person<string, int> p("张三", 13);
	p.showPerson();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp

### 1.3.8 类模板与友元
掌握类模板配合友元函数的类内和类外实现  
全局函数类内实现 —— 直接在类内声明友元即可  
全局函数类外实现 —— 需要提前让编译器知道全局函数的存在  
示例：
```cpp
// 2. 全局函数配合友元 类外实现 —— 先做函数模板声明，下方再做函数模板定义，再做友元
template<class T1, class T2> class Person;

// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
template<class T1, class T2>
void printPerson2(Person<T1, T2>& p)
{
	
}

template<class T1, class T2>
class Person
{
	// 1. 全局函数配合友元 类内实现
	friend void printPerson(Person<T1, T2>& p)
	{
		...
	}

	// 2. 全局函数配合友元 类外实现
	friend void printPerson2<>(Person<T1, T2>& p);

private:
	T1 name;
	T2 age;
};
```
>小结：  
建议全局函数做类内实现，用法简单，而且编译器可以直接识别

### 1.3.9 类模板案例
案例描述：实现一个通用的数组类，要求如下：
- 可以对内置数据类型以及自定义数据类型的数据进行存储
- 将数组中的数据存储到堆区
- 构造函数中可以传入数组的容量
- 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
- 提供尾插法和尾删法对数组中的数据进行增加和删除
- 可以通过下标的方式访问数组中的元素
- 可以获取数组中当前元素个数和数组的容量

示例：  
myArray.hpp
```cpp
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
	// 构造函数
	MyArray(int capacity)
	{
		this->m_Capacity = capacity;
		this->m_Size = 0;
		pAddress = new T[this->m_Capacity];
	}

	// 拷贝构造
	MyArray(const MyArray& arr)
	{
		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			// 如果T为对象，而且还包含指针，必须需要重载=操作符，因为这个等号不是构造而是赋值
			// 普通类型可以直接= 但是指针类型需要深拷贝
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	// 重载 = 操作符  防止浅拷贝问题
	MyArray& operator=(const MyArray& arr)
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->m_Capacity = 0;
			this->m_Size = 0;
		}

		this->m_Capacity = arr.m_Capacity;
		this->m_Size = arr.m_Size;
		this->pAddress = new T[this->m_Capacity];
		for (int i = 0; i < this->m_Size; i++)
		{
			this->pAddress[i] = arr.pAddress[i];
		}
	}

	// 重载[] 操作符 arr[0]
	T& operator [](int index)
	{
		return this->pAddress[index];
	}

	// 尾插法
	void Push_back(const T& val)
	{
		if (this->m_Capacity == this->m_Size)
		{
			return;
		}
		this->pAddress[this->m_Size] = val;
		this->m_Size++;
	}

	// 尾删法
	void Pop_back()
	{
		if (this->m_Size == 0)
		{
			return;
		}
		this->m_Size--;
	}

	// 获取数组容量
	int getCapacity()
	{
		return this->m_Capacity;
	}

	// 获取数组大小
	int getSize()
	{
		return this->m_Size;
	}

	// 析构
	~MyArray()
	{
		if (this->pAddress != NULL)
		{
			delete[] this->pAddress;
			this->pAddress = NULL;
			this->m_Size = 0;
			this->m_Capacity = 0;
		}
	}

private:
	T* pAddress; // 指向一个堆空间，这个空间存储真正的数据
	int m_Capacity; // 容量
	int m_Size; // 大小
};
```
main.cpp测试：
```cpp
#include "MyArray.hpp"

void test01()
{
	MyArray<int> a1(10); // 可初始化各种数据类型，包括自定义数据类型
	for (int i = 0; i < 10; i++)
	{
		a1.Push_back(i);
		cout << a1[i] << endl;
	}
	cout << a1.getSize() << endl;
	
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
利用所学知识点实现通用的数组


# 二、STL初始
## 2.1 STL的诞生
- 长久以来，软件界一直希望建立一种可重复利用的东西
- cpp的**面向对象**和**泛型编程**思想，目的就是**复用性的提升**
- 大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
- 为了建立数据结构和算法的一套标准，诞生了**STL**

## 2.2 STL基本概念
- STL（Standard Template Library，标准模板库）
- STL从广义上分为：容器 算法 迭代器
- **容器**和**算法**之间通过**迭代器**进行无缝连接
- STL几乎所有的代码都采用了模板类或者模板函数

## 2.3 STL六大组件
STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
1. 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂
4. 仿函数：行为类似函数，可作为算法的某种策略
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西
6. 空间适配器：负责空间的配置和管理

## 2.4 STL中容器、算法、迭代器
**STL容器**：置物之所也；将运用最广泛的一些数据结构实现出来  
常用的数据结构：数组、链表、树、栈、队列、集合、映射表等   
这些容器分为**序列式容器**和**关联式容器**两种：  
序列式：强调值得排序，序列式容器中的每个元素均有固定的位置
关联式：二叉树结构，各元素之间没有严格的物理上的顺序关系

**算法**：问题之解法也；有限的步骤解决逻辑或数学上的问题  
算法分为：**质变算法**和**非质变算法**：  
质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝、替换、删除等等  
非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等  

**迭代器**：容器和算法之间粘合剂；提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。  
每个容器都有自己专属的迭代器  
迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针  
迭代器种类：  
1. 输入迭代器：只读 ++ ==
2. 输出迭代器：只写 ++
3. 前向迭代器：读写 ++ ==
4. 双向迭代器：读写 ++ --
5. 随机访问迭代器：读写，跳跃访问 +5 [n] >=

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器

## 2.5 容器算法迭代器初识
了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力  
STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器
### 2.5.1 vector存放内置数据类型
容器：```vector```  
算法：```for_each```  
迭代器：```vector<int>::iterator```  
示例：
```cpp
#include <iostream>
#include <vector> // vector用
#include <algorithm> // for_each用
using namespace std;

void func(int n)
{
	cout << n + 1 << endl;
}

void test01()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

	// 每个容器都有自己的迭代器，迭代器用来遍历容器中的元素
	vector<int>::iterator pBegin = v.begin(); // 返回迭代器，指向容器中第一个数据
	vector<int>::iterator pEnd = v.end();  // 返回迭代器，指向容器元素的最后一个元素的下一个位置

	// 方法一
	while (pBegin != pEnd)
	{
		cout << *pBegin << endl;
		pBegin++;
	}

	// 方法二
	for (vector<int>::iterator i = v.begin(); i != v.end(); i++)
	{
		cout << *i << endl;
	}

	// 方法三
	// 使用STL提供的标准遍历算法 头文件 algorithm
	for_each (v.begin(), v.end(), func);
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 2.5.2 Vector存放自定义数据类型
Vector中存放自定义数据类型，并打印输出  
示例：
```cpp
// 存放对象
for (vector<Person>::iterator it = v.begin(); it != v.end()l it ++)
{
	cout << (*it).name;
	cout << it->name;
}

// 存放指针
vector<Person*> v;
Person p1("aaa", 10);
v.push_back(&p1);

for (vector<Person*>::iterator it = v.begin(); it != v.end()l it ++)
{
	cout << (*it)->name // *it是Person *类型
}
```

### 2.5.3 Vector容器嵌套容器
示例：
```cpp
for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it ++)
{
	for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++)
	{
		cout << *vit << endl;
	}
}
```


# 三、STL - 常用容器
## 3.1 string容器
### 3.1.1 string基本概念
**本质**：
- string是cpp风格的字符串，而string本质上是一个类
**string**和**char***的区别：  
- char* 是一个指针
- string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器

**特点**：  
string类内部封装了很多成员方法  
例如：查找find，拷贝copy，删除delete，替换replace，插入insert  
string管理char*所分配的内存，不用担心赋值越界和取值越界等，由类内部进行负责  

### 3.1.2 string构造函数  
构造函数原型：
- string(); 创建一个空的字符串 例如：string str；  
string(const char* s); 使用字符串s初始化
- string(const string& str); 使用一个string对象初始化另一个string对象
- string(int n, char c); 使用n个字符c初始化
```cpp
string s1; // 创建空字符串，调用无参构造函数
cout << "str1 = " << s1 << endl; // 啥也不输出

const char* str = "hello world";
string s2(str); // 把c_string转换成了string
cout << "str2 = " << s2 << endl;

string s3(s2); // 调用拷贝构造函数
cout << "str3 = " << s3 << endl;

string s4(10, 'a');
cout << "str4 = " << s4 << endl;
```
>小结：  
string的多轴构造方式没有可比性，灵活使用即可

### 3.1.3 string赋值操作
功能描述：给string字符串进行赋值  
赋值的函数原型：
- ```string& operator=(const char* s);``` // char*类型字符串 赋值给当前的字符串
- ```string& operator=(const string &s);``` // 把字符串s赋给当前的字符串
- ```string& operator=(char c);``` // 字符赋值给当前的字符串
- ```string& assign(const char *s);``` // 把字符串s赋给当前的字符串
- ```string& assign(const char *s, int n);``` // 把字符串s的前n个字符赋给当前的字符串
- ```string& assign(const string &s);``` // 把字符串s赋给当前字符串
- ```string& assign(int n, char c);``` // 用n个字符c赋给当前字符串

示例：
```cpp
string s1 = "hello world";

string s2 = s1;

string s3;
s3 = 'a';

string s4;
s4.assign("hello cpp");

string s5;
s5.assign("helloaaaa", 5);

string s6;
s6.assign(s5);

string s7;
s7.assign(5, 'x');

cout << s7;
```
>小结：  
string的赋值方式很多，```operator=```这种方式是比较常用的

### 3.1.4 string字符串拼接
**功能描述**：
- 实现在字符串末尾拼接字符串

函数原型：
- ```string& operator+=(const char* str);``` // 重载+=操作符 
- ```string& operator+=(const char c);``` // 重载+=操作符
- ```string& operator+=(const string& str);``` // 重载+=操作符
- ```string& append(const char *s);``` // 把字符串s连接到当前字符串结尾
- ```string& append(const char *s, int n);``` // 把字符串s的前n个字符连接到当前字符串结尾
- ```string& append(const string &s);``` // 同operator+=(const string &str)
- ```string& append(const string &s, int pos, int n);``` // 字符串s中从pos开始的n个字符连接到字符串结尾
```cpp
string s1 = "我";

s1 += "爱玩游戏";

string s2 = "哈哈DNFFFF";
s1 += s2;

string s3 = "I";
s3.append("love");
s3.append("your girlfriend", 4);

s3.append(s2, 4, 3);
cout << s3 << endl;
```
>小结：  
字符串拼接的重载版本很多，初学阶段记住几种即可

### 3.1.5 string查找和替换
**功能描述**：  
- 查找：查找指定字符串是否存在
- 替换：在指定的位置替换字符串

函数原型：  
左到右查找：
- ```int find(const string& str, int pos = 0) const;``` // 查找str第一次出现位置，从pos开始查找
- ```int find(const char* s, int pos = 0) const;``` // 查找s第一次出现位置，从pos开始查找
- ```int find(const char* s, int pos, int n) const;``` // 从pos位置查找s的前n个字符第一次位置
- ```int find(const char c, int pos = 0) const;``` // 查找字符c第一次出现位置

(本质是右到左查找：
- ```int rfind(const string& str, int pos = npos) const;``` // 查找str最后一次出现位置即从右往左的第一次，从pos开始查找
- ```int rfind(const char* s, int pos = npos) const;``` // 查找s最后一次出现位置，从pos开始查找
- ```int rfind(const char* s, int pos, int n) const;``` // 从pos位置查找s的前n个字符最后一次位置
- ```int rfind(const char c, int pos = 0) const;``` // 查找字符最后一次出现位置

替换：
- ```string& replace(int pos, int n, const string& str);``` // 替换从pos开始n个字符为字符串str
- ```string& replace(int pos, int n, const char*s);``` // 替换从pos开始n个字符为字符串s

```cpp
string s = "this is";
cout << s.find("is") << endl; // 2
cout << s.rfind("is") << endl; // 5
```
>小结：  
find查找是从左往右，rfind是从右往左  
find找到字符串后返回查找的第一个字符位置，找不到返回-1  
replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串

### 3.1.6 string字符串比较
**功能描述**：字符串之间的比较  
**比较方式**：按照字符的ASCII码进行对比  
= 返回 0  
\> 返回 1  
< 返回 -1  
**函数原型**：  
- int compare(const string &s) const; // 与字符串s比较
- int compare(const char *s) const; // 与字符串s比较  
示例：
```cpp
string s1 = "hello";
string s2 = "aello";

int res = s1.compare(s2);

cout << res << endl; // a在h前 输出1
```

### 3.1.7 string字符存取
string中单个字符存取方式有两种
- ```char& operator[](int n);``` // 通过[]方式取字符
- ```char& at(int n);``` // 通过at方法获取字符
```cpp
string s1 = "hello";
string s2 = "aello";

for (int i = 0; i < s1.size(); i++)
{
	cout << s1[i] << endl;
	cout << s1.at(i) << endl;
}

s1[0] = 'a';
s1.at(1) = 'b';
cout << s1 << endl;
```

### 3.1.8 string插入和删除
**功能描述**：对string字符串进行插入和删除字符操作，起始下标都从0开始  
**函数原型**：
- ```string& insert(int pos, const char *s);``` // 插入字符串
- ```string& insert(int pos, const string &str);``` // 插入字符串
- ```string& insert(int pos, int n, char c);``` // 在指定位置插入n个字符c
- ```string& erase(int pos, int n = npos);``` // 删除从Pos开始的n个字符

示例：
```cpp
void test01()
{
	string s1 = "hello";
	
	s1.insert(1, "111");
	cout << s1 << endl;

	s1.erase(1, 3);
	cout << s1 << endl;
}
```

### 3.1.9 string子串
**功能描述**：从字符串中获取想要的字符串   
**函数原型**：
- ```string substr(int pos = 0, int n = npos) const; // 返回由pos开始的n个字符组成的字符串
```cpp
void test01()
{
	string s1 = "hello";
	string substr = s1.substr(1, 3);
	cout << substr << endl;

	string email = "lwl@163.com";
	int pos = email.find("@");
	string name = email.substr(0, pos);
	cout << name << endl;
}
```

## 3.2 vector容器
### 3.2.1 vector基本概念
**功能描述**：vector数据结构和数组非常相似，也称为**单端数组**  
vector与普通数组区别：
- 不同之处在于数组是静态控件，而vector可以**动态扩展**

**动态扩展**：
- 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间
- vector容器的迭代器是支持随机访问的迭代器

### 3.2.2 vector构造函数
**功能描述**：创建vector容器  
**函数原型**：
- ```vector<T> v;``` // 采用模板实现类实现，默认构造函数
- ```vector(v.begin(), v.end());``` // 将v.begin(), v.end()中间的元素拷贝给自身
- ```vector(n, elem);``` // 构造函数将n个elem拷贝给本身
- ```vector(const vector &vec);``` // 拷贝构造函数

示例：
```cpp
void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}

	vector<int> v2(v1.begin(), v1.end());

	vector<int> v3(10, 100);

	vector<int> v4 (v3);

	for (int i = 0; i < 10; i++)
	{
		cout << v3[i] << endl;
	}
}
```

### 3.2.3 vector赋值操作
**功能描述**：给vector容器进行赋值  
**函数原型**：
- ```vector& operator=(const vector &vec);``` // 重载等号操作符
- ```assign(beg, end);``` // 将[beg, end)区间中的数据拷贝赋值给本身
- ```assign(n, elem);``` // 将n个elem拷贝赋值给本身
```cpp
void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}

	vector<int> v2;
	v2 = v1;
	printVector(v2);

	vector<int> v3;
	v3.assign(v1.begin(), v1.end());
	printVector(v3);

	vector<int> v4;
	v4.assign(10, 100);
	printVector(v4);
}
```

### 3.2.4 vector容量和大小
**功能描述**：对vector容器的容量和大小操作  
**函数原型**：
- ```empty();``` 判断容器是否为空
- ```capacity();```容器的容量
- ```size();``` 返回容器中元素的个数
- ```resize(int num);``` 重新指定容器的长度为num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除
- ```resize(int num, elem);``` 重新指定容器的长度为num，若容器变长，则以elem值填充新位置；若容器变短，则末尾超出容器长度的元素被删除
```cpp
void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	cout << v1.capacity() << endl;

	v1.resize(15, 10);
	cout << v1.capacity() << endl;
	printVector(v1);

	v1.resize(5);
	cout << v1.capacity() << endl;
	printVector(v1);
}
```

### 3.2.5 vector插入和删除
**功能描述**：对vector进行插入、删除操作  
**函数原型**：
- ```push_back(ele);``` 尾部插入元素ele
- ```pop_back();``` 删除最后一个元素
- ```insert(const_iterator pos, ele);``` 迭代器指向位置pos插入元素ele
- ```insert(const_iterator pos, int count, ele);``` 迭代器指向位置pos插入count个元素ele
- ```erase(const_iterator pos);``` 删除迭代器指向的元素
- ```erase(consr_iterator start, const_iterator end);``` 删除迭代器从start到end之间的元素
- ```clear();``` 删除容器中所有元素

示例：
```cpp
void test01()
{
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);

	v1.pop_back();
	printVector(v1);

	v1.insert(v1.begin(), 100);
	printVector(v1);

	v1.insert(v1.begin(), 3, 20); 
	printVector(v1);

	v1.erase(v1.begin(), v1.end());
	printVector(v1);

	v1.clear();
	printVector(v1);
}
```

### 3.2.6 vector数据存取
**功能描述**：对vector中的数据的存取操作  
**函数原型**：  
- ```at(int idx);``` 返回索引idx所指的数据
- ```operator[];``` 返回索引idx所指的数据
- ```front();``` 返回容器中第一个数据元素
- ```back();``` 返回容器中最后一个数据元素
```cpp
void test01()
{
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);

	v1.pop_back();
	cout << v1.back() << endl;

	cout << v1.front()<< endl;

	v1.insert(v1.begin(), 3, 20); 
	printVector(v1);
	cout << v1.at(3) << endl;
}
```

### 3.2.7 vector互换容器
**功能描述**：实现两个容器内元素进行互换  
**函数原型**：
- ```swap(vec);``` 将vec与本身的元素互换

示例：
```cpp
void test01()
{
	vector<int> v1;
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);

	vector<int> v2;
	v2.push_back(30);
	v2.push_back(20);
	v2.push_back(10);

	v1.swap(v2);
	printVector(v1);
	printVector(v2);

	v2.resize(1);
	printVector(v2);
	cout << v2.capacity() << endl; // 3
	// 重点：巧用swap收缩内存
	vector<int>(v2).swap(v2);
	cout << v2.capacity() << endl; // 1
}
```

### 3.2.8 vector预留空间
**功能描述**：减少vector在动态扩展容量时的扩展次数  
**函数原型**：
- ```reserve(int len);``` 容器预留len个元素长度，预留位置不初始化，元素不可访问
```cpp
void test01()
{
	vector<int> v;

	// 预留空间
	v.reserve(100000);

	int num = 0;
	int* p = NULL;
	for (int i = 0; i < 100000; i++)
	{
		v.push_back(i);
		if (p != &v[0]) // 在达到预留空间数前不需要再继续动态扩容
		{
			p = &v[0];
			num++;
		}
	}

	cout << num << endl;
}
```

## 3.3 deque容器
### 3.3.1 deque容器基本概念
**功能**：双端数组，可以对头端进行插入删除操作  
**deque**与**vector**区别：
- vector对于头部的插入删除效率低，数据量越大，效率越低
- deque相对而言，对头部的插入删除速度会比vector快
- vector访问元素时的速度会比deque快，这和两者内部实现有关

deque**内部**工作原理：  
deque内部有个**中控器**，维护每段缓冲区中的内容，缓冲区中存放真实数据  
中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间  
deque容器的迭代器也是支持随机访问的

### 3.3.2 deque构造函数
**功能描述**：deque容器构造  
**函数原型**：
- ```deque<T> deqT;``` 默认构造形式
- ```deque(beg, end);``` 构造函数将[beg, end)区间中的元素拷贝给本身
- ```deque(n, elem);``` 构造函数将n个elem拷贝给本身
- ```deque(const deque &deq);``` 拷贝构造函数

示例：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <deque>
using namespace std;

void printDeque(const deque<int>& d)
{
	for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	deque<int> d1;
	for (int i = 0; i < 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	deque<int> d2(d1.begin(), d1.end());
	printDeque(d2);

	deque<int> d3(3, 33);
	printDeque(d3);

	deque<int>d4 = d3;
	printDeque(d4);
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 3.3.3 deque赋值操作
**功能描述**：给deque容器进行赋值  
**函数原型**：
- ```deque& operator=(const deque &deq);``` 重载等号操作符
- ```assign(beg, end);``` 将[beg, end)区间中的数据拷贝赋值给本身
- ```assign(n, elem);``` 将n个elem拷贝赋值给本身

### 3.3.4 deque大小操作
同vector；但deque**没有容量**概念

### 3.3.5 deque插入和删除
**功能描述**：向deque容器中插入和删除数据  
**函数原型**：  
两端插入操作：  
- ```push_back(elem);``` 在容器尾部添加一个数据
- ```push_front(elem);``` 在容器头部插入一个数据
- ```pop_back();``` 删除容器最后一个数据
- ```pop_front();``` 删除容器第一个数据

指定位置操作：
- ```insert(pos, elem);``` 在pos位置插入一个elem元素的拷贝，返回新数据的位置
- ```insert(pos, n, elem);``` 在pos位置插入n个elem数据，无返回值
- ```insert(pos, beg, end);``` 在pos位置插入[beg, end)区间的数据，无返回值
- ```clear();``` 清空容器的所有数据
- ```erase(beg, end)``` 删除[beg, end)区间的数据，返回下一个数据的位置
- ```erase(pos);``` 删除pos位置的数据，返回下一个数据的位置

示例：
```cpp
void test01()
{
	deque<int> d1;
	d1.push_back(10);
	d1.push_back(20);

	d1.push_front(100);
	d1.push_front(200);

	printDeque(d1);

	d1.pop_front();
	d1.pop_back();
	printDeque(d1);

	d1.insert(d1.begin(), 300);
	d1.insert(d1.end(), 3, 400);
	d1.insert(d1.begin(), d1.begin(), d1.end());
	d1.erase(d1.begin());
	d1.erase(d1.begin(), d1.end());
	d1.clear();
	printDeque(d1);
}
```

### 3.3.6 deque数据存取
同vector；

### 3.3.7 deque排序
算法：
- ```sort(iterator beg, iterator end)``` 对beg和end区间内元素进行排序  

算法实现：
```cpp
sort(d1.begin(), d1.end()); // 使用时包含头文件algorithm即可
```

## 3.4 案例-评委打分
### 3.4.1 案例描述
