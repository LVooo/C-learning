# cpplearning
[toc]

本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓
## 一、内存分区模型
C++程序在执行时，将内存大方向划分为**4个区域**  
- **代码区**：存放函数体的二进制代码，由操作系统进行管理的
- **全局区**：存放全局变量和静态变量以及常量
- **栈区**：由编译器自动分配释放，存放函数的参数值，局部变量等
- **堆区**：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

**内存四区意义**：  
不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程空间  

### 1.1程序运行前
在程序编译后，生成了exe可执行程序，**未执行**该程序前分为两个区域  
**代码区**：
- 存放CPU执行的机器指令
- 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区**：
- 全局变量和静态变量存放在此
- 全局区还包含了常量区，字符串常量和其他常量也存放在此
- 该区域的数据在程序结束后由操作系统释放

ex：
```cpp
// 全局变量
int g_a = 10;
int g_b = 10;

// 全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main()
{
    // 局部变量
    int a = 10;
    int b = 10;

    // 打印地址
    (int)&a // 13629532
    (int)&b // 13629520

    (int)&g_a //15646784
    (int)&g_b // 15646788

    //静态变量
    static int s_a = 10;
    static int s_b = 10;

    (int)&s_a // 15646792
    (int)&s_b // 15646796

    (int)&"hello world" // 15637396

    const int c_l_a = 10;
    const int c_l_b = 10;

    (int)&c_g_a // 15637564
    (int)&c_g_b // 15637568
    (int)&c_l_a // 13629508
    (int)&c_l_b // 13629496
}
```
>小结：  
全局区中存放全局变量、静态变量、常量  
常量区中存放const修饰的全局变量和字符串常量

![global variable](https://img-blog.csdnimg.cn/img_convert/4a8d4ec1ff367a28099be7ca8261a81e.png)

### 1.2程序运行后
**栈区**：  
- 由编译器自动分配释放，存放函数的参数值，局部变量等
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放  
ex：
```cpp
int* func()
{
	int a = 10; //局部变量  存放在栈区，栈区的数据在函数执行完后自动释放
	return &a;	//返回局部变量的地址
}
int main()
{
	//接收func函数的返回值
	int* p = func();
	cout << "*p = " << *p << endl;//第一次可以打印正确的数字，是因为编译器做了保留(在x86环境下)，x64两次都返回随机值
	cout << "*p = " << *p << endl;//第二次这个数据就不再保留

	system("pause");
	return 0;
}
```
输出
```cpp
*p = 1
*p = 2052299144
```

**堆区**：  
由程序员分配释放，若程序员不释放，程序结束时由操作系统回收  
在C++中主要利用new在堆区开辟内存  
ex：
```cpp
int* func()
{
	// 利用new关键字 可以将数据开辟到堆区
	// 指针本质上也是局部变量，放在栈内，指针保存的数据放在堆区
	int* p = new int(10);
	return p;
}
int main()
{
	// 在堆区开辟数字
	int* p = func();
	cout << "*p = " << p << endl; // 解引用
	cout << "*p = " << p << endl;

	system("pause");
	return 0;
}
```
输出
```cpp
*p = 10
*p = 10
```
>小结  
函数里的指针为局部变量，存放在栈内。指针保存的数据为指向堆区的地址，解引用堆区的地址获得堆区存放的值

### 1.3new操作符
>C++中利用new操作符在堆区开辟数据  
堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete

语法：```new 数据类型```  
利用new创建的数据，会返回该数据对应的类型的指针。 
```cpp
void test()
{
	int* p = func();
	cout << "*p = " << *p << endl;
	cout << "*p = " << *p << endl;

	delete p; // 利用关键字delete来释放堆区中的数据
	cout << "*p = " << *p << endl; // 内存已经被释放，再访问就是非法操作，报错
}
```
开辟数组：
```cpp
int *arr = new int[10]; //10代表数组中有十个元素
delete[] arr; // 释放数组时要加[]
```

&nbsp;
## 二、引用
### 2.1 引用的基本使用
**作用**：给变量起别名  
**语法**：```数据类型 &别名 = 原名```  
ex:
```cpp
void test()
{
    int a = 10;
    int& b = a;

    cout << a << "\t" << b << endl; // 10 10

    b = 20;
    cout << a << "\t" << b << endl; // 20 20
}
```

### 2.2 引用注意事项
- 引用必须初始化
- 引用在初始化后，**不可更改**  
ex：
```cpp
void test()
{
	int a = 10;
    // int &b; //错误，引用必须初始化
	int& b = a;

	int c = 20;
	b = c; // 赋值操作，而不是更改引用
	cout << &a << "\t" << &b << '\t' << &c << endl; // 可以发现a和b的地址是一样的，只是值都变成了20
}
```

### 2.3 引用做函数参数
**作用**：函数传参时，可以利用引用的技术让形参修饰实参  
**有点**：可以简化指针修改实参  
ex：
```cpp
void swap1(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void swap2(int &a, int &b)
{
	int c = 30;
	int tmp = a;
	a = c;
	b = tmp;
}

void test()
{
	int a = 10;
	int b = 20;

// 	swap1(&a, &b); // 地址传递，形参会修饰实参
	swap2(a, b); // 引用传递，同地址传递，形参也会修饰实参

	cout << "a=" << a << " b=" << b << endl;
}
```
>小结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更清晰简单。

### 2.4 引用做函数返回值
**作用**：引用是可以作为函数的返回值存在的  
**注意**：不要返回局部变量引用  
**用法**：函数调用作为左值  
ex：
```cpp
// 1.不要返回局部变量的引用
int& test1()
{
	int a = 10; // 局部变量存放在四区中的栈区
	return a;
}

// 2.函数的调用可以作为左值
int& test2()
{
	static int a = 10; // 静态变量，存放在全局区，在程序结束后系统释放
	return a;
}

int main()
{
	//int& ref = test1();
	//cout << "ref = " << ref << endl; // 编译器保留输出正确结果
	//cout << "ref = " << ref << endl; // 局部变量内存释放结果错误

	int& ref = test2();
	cout << "ref = " << ref << endl; // 10
	test2() = 100; // 如果函数返回值是引用，这个函数调用可以作为左值
	cout << "ref = " << ref << endl; // 100，因为a的别名是ref2
 
	system("pause");
	return 0;
}
```

### 2.5 引用的本质
**作用**：引用的本质在C++内部实现是一个**指针常量**  
ex：
```cpp
// 发现是引用，转换为 int* const ref = &a
void func(int &ref)
{
	ref = 100;
}

int main()
{
	int a = 10;
	// 自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int& ref = a;

	ref = 20; // 内部发现ref是引用，自动帮我们转换为：*ref = 20；
	cout << "a = " << a << endl; // 20
	cout << "ref = " << ref << endl; // 20

	func(a);
	cout << "a = " << a << endl; // 100
	cout << "ref = " << ref << endl; // 100
 
	system("pause");
	return 0;
}
```
>小结：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了

### 2.6 常量引用
**作用**：常量引用主要用来修饰形参，防止误操作  
在函数形参列表中，可以加**const修饰形参**，防止形参改变实参  
ex：
```cpp
void showValue(const int& val)
{
	// val = 1000; // 不可更改
	cout << "val = " << val << endl;
}

int main()
{
	// int a = 10;
	// int &ref = 10; 错误！！引用必须引用一块合法的内存空间

	// 加上const之后，编译器将代码修改成 int temp = 10; const int &ref = temp;
	const int& ref = 10;
	// ref = 20; // 加入const之后变为只读，不可以修改

	int a = 100;
	showValue(a); // 100

	cout << "a = " << a << endl; // 100

	system("pause");
	return 0;
}
```
>小结：```const```可以修饰：  
变量  
结构体  
常量引用

&nbsp;
## 三、函数提高
>在C++中，函数的形参列表中的形参是可以有默认值的
### 3.1 函数默认参数
**语法**：```返回值类型 函数名 (参数=默认值) {}```  
ex：
```cpp
//如果我们自己传入数据，就用自己的数据，如果没有，那么用默认值
// 注意：
//1.如果某个位置已经有了默认参数，那么从这个位置往后，从左到右必须都有默认值
int func(int a, int b = 20, int c = 30)
{
	return a + b + c;
}

//2.如果函数的声明有了默认参数，函数实现就不能有默认参数
//声明和实现只能有一个默认参数
int func2(int a = 30, int b = 50);
int func2(int a, int b)
{
	return a + b;
}

int main()
{
	cout << func(10) << endl; // 60
	cout << func(10, 30) << endl; // 70
	cout << func2() << endl; // 80

	system("pause");
	return 0;
}
```

### 3.2 函数占位参数
>C++中函数的形参列表可以有占位参数，用来做占位，调用函数时必须填补该位置

语法：```返回值类型 函数名 (数据类型){}```  
在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术  
ex：
```cpp
void func(int a, int)
{
	cout << "func1" << endl;
}

void func2(int a, int =10)
{
	cout << "func2" << endl;
}

int main()
{
	func(10, 10); // func1
	func2(1); // func2
	func2(1); // func2

	system("pause");
	return 0;
}
```

### 3.3 函数重载
#### 3.3.1 函数重载概述
**作用**：函数名可以相同，提高复用性  
**函数重载满足条件**：
- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**  
**注意**：函数的返回值不可以作为函数重载的条件
```cpp
//函数重载
//可以让函数名相同，提高复用性
//函数重载的满足条件:
//1.同一个作用域下 2.函数名称相同 3.函数参数类型不同，或者个数不同，或者顺序不同
void func()
{
	cout << "func 的调用" << endl;
}
//个数不同
void func(int a)
{
	cout << "func(int a) 的调用" << endl;
}
//参数类型不同
void func(double a)
{
	cout << "func(double a) 的调用" << endl;
}
//顺序不同
void func(int a, double b)
{
	cout << "func(int a,double b) 的调用" << endl;
}
void func(double a, int b)
{
	cout << "func(double a,int b) 的调用" << endl;
}
//注意事项
//函数的返回值不可以作为函数重载的条件
//int func(double a, int b)
//{
//	cout << "func(double a,int b) 的调用" << endl;
//	return 0;
//}
int main()
{
	func(); // func 的调用
	func(10); // func(int a) 的调用
	func(3.14); // func(double a) 的调用
	func(10, 3.14); // func(int a,double b) 的调用
	func(3.14, 10); // func(double a,int b) 的调用

	system("pause");
	return 0;
}
```
其实**有接收变量**的情况下，**函数的返回值也可以作为函数重载的条件**
```cpp
int func(int a, double b)
{
	cout << "func1" << endl; // 输出func1
	return 0;
}

int func(int a, int b)
{
	cout << "func2" << endl;
	return 0;
}

int main()
{
	int a = func(10, 3.14);

	system("pause");
	return 0;
}
```

#### 3.3.2 函数重载注意事项
- 引用作为重载条件
- 函数重载碰到函数默认参数  
ex：
```cpp
// 1.引用作为重载的条件
void func(int& a)
{
	cout << "func(int& a)调用" << endl;
}

void func(const int& a)
{
	cout << "func(const int& a)调用" << endl;
}

// 2.函数重载碰到默认参数
void func2(int a, int b = 10)
{
	cout << "func2(int a, int b = 10)调用" << endl;
}

void func2(int a)
{
	cout << "func2(int a)调用" << endl;
}

int main()
{
	int a = 10;
	func(a); // 输出func(int& a)调用
	func(10); // int &a=10 不合法； const int &a = 10 合法
    // 输出func(const int& a)调用

	//func2(10); // 当函数重载碰到默认参数，出现二义性，报错

	system("pause");
	return 0;
}
```

&nbsp;
## 四、类对象
>C++面向对象的三大特性为：**封装、继承、多态**  
C++认为万事万物都皆为对象，对象上有其属性和行为

ex：
>人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...  
车也可以作为对象，属性有轮胎、方向盘、车灯...，行为有载人、放音乐、放空调...  
具有相同性质的**对象**，我们可以抽象成为**类**，人属于人类，车属于车类

### 4.1 封装
#### 4.1.1 封装的意义
>封装是C++面向对象三大特性之一

封装的意义：
- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

意义一：
>在设计类的时候，属性和行为写在一起，表现事物  
语法：```class 类名{访问权限：属性 / 行为};  

ex1：设计一个圆类，求圆的周长
```cpp
#include <iostream>
using namespace std;

const double PI = 3.14;

class Circle
{
	// 访问权限
public: // 公共权限
	// 属性
	int radius;

	// 行为
	double cacluteZC()
	{
		return 2 * radius * PI;
	}

};

int main()
{
	// 通过圆类 创建具体的圆（对象）
	Circle c;
	// 给圆对象的属性进行赋值
	c.radius = 10;

	cout << c.cacluteZC() << endl; // 62.8

	system("pause");
	return 0;
}
```
ex2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号
```cpp
class Student
{
public:
	// 类中的属性和行为 我们统一称为成员
	// 属性 成员属性 成员变量
	// 行为 成员函数 成员方法


	string name;
	int number;

	void showInfo()
	{
		cout << "学生的姓名是：" << name << " 编号为：" << number << endl;
	}
};

int main()
{
	Student s1;
	s1.name = "小葛";
	s1.number = 5332112;
	
	s1.showInfo(); // 学生的姓名是：小葛 编号为：5332112

	system("pause");
	return 0;
}
```

意义二：
>类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：
1. public 公共权限
2. protected 保护权限
3. private 私有权限

ex：
```cpp