# C++learning
[toc]

本阶段主要针对C++**面向对象**编程技术做详细讲解，探讨C++中的核心和精髓
# 一、内存分区模型
C++程序在执行时，将内存大方向划分为**4个区域**  
- **代码区**：存放函数体的二进制代码，由操作系统进行管理的
- **全局区**：存放全局变量和静态变量以及常量
- **栈区**：由编译器自动分配释放，存放函数的参数值，局部变量等
- **堆区**：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

**内存四区意义**：  
不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程空间  

## 1.1程序运行前
在程序编译后，生成了exe可执行程序，**未执行**该程序前分为两个区域  
**代码区**：
- 存放CPU执行的机器指令
- 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区**：
- 全局变量和静态变量存放在此
- 全局区还包含了常量区，字符串常量和其他常量也存放在此
- 该区域的数据在程序结束后由操作系统释放

ex：
```cpp
// 全局变量
int g_a = 10;
int g_b = 10;

// 全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main()
{
    // 局部变量
    int a = 10;
    int b = 10;

    // 打印地址
    (int)&a // 13629532
    (int)&b // 13629520

    (int)&g_a //15646784
    (int)&g_b // 15646788

    //静态变量
    static int s_a = 10;
    static int s_b = 10;

    (int)&s_a // 15646792
    (int)&s_b // 15646796

    (int)&"hello world" // 15637396

    const int c_l_a = 10;
    const int c_l_b = 10;

    (int)&c_g_a // 15637564
    (int)&c_g_b // 15637568
    (int)&c_l_a // 13629508
    (int)&c_l_b // 13629496
}
```
>小结：  
全局区中存放全局变量、静态变量、常量  
常量区中存放const修饰的全局变量和字符串常量

![global variable](https://img-blog.csdnimg.cn/img_convert/4a8d4ec1ff367a28099be7ca8261a81e.png)

## 1.2程序运行后
**栈区**：  
- 由编译器自动分配释放，存放函数的参数值，局部变量等
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放  
ex：
```cpp
int* func()
{
	int a = 10; //局部变量  存放在栈区，栈区的数据在函数执行完后自动释放
	return &a;	//返回局部变量的地址
}
int main()
{
	//接收func函数的返回值
	int* p = func();
	cout << "*p = " << *p << endl;//第一次可以打印正确的数字，是因为编译器做了保留(在x86环境下)，x64两次都返回随机值
	cout << "*p = " << *p << endl;//第二次这个数据就不再保留

	system("pause");
	return 0;
}
```
输出
```cpp
*p = 1
*p = 2052299144
```

**堆区**：  
由程序员分配释放，若程序员不释放，程序结束时由操作系统回收  
在C++中主要利用new在堆区开辟内存  
ex：
```cpp
int* func()
{
	// 利用new关键字 可以将数据开辟到堆区
	// 指针本质上也是局部变量，放在栈内，指针保存的数据放在堆区
	int* p = new int(10);
	return p;
}
int main()
{
	// 在堆区开辟数字
	int* p = func();
	cout << "*p = " << *p << endl; // 解引用
	cout << "*p = " << *p << endl;

	system("pause");
	return 0;
}
```
输出
```cpp
*p = 10
*p = 10
```
>小结  
函数里的指针为局部变量，存放在栈内。指针保存的数据为指向堆区的地址，解引用堆区的地址获得堆区存放的值

## 1.3new操作符
>C++中利用new操作符在堆区开辟数据  
堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete

语法：```new 数据类型```  
利用new创建的数据，会返回该数据对应的类型的指针。 
```cpp
void test()
{
	int* p = func();
	cout << "*p = " << *p << endl;
	cout << "*p = " << *p << endl;

	delete p; // 利用关键字delete来释放堆区中的数据
	cout << "*p = " << *p << endl; // 内存已经被释放，再访问就是非法操作，报错
}
```
开辟数组：
```cpp
int *arr = new int[10]; //10代表数组中有十个元素
delete[] arr; // 释放数组时要加[]
```

&nbsp;
# 二、引用
## 2.1 引用的基本使用
**作用**：给变量起别名  
**语法**：```数据类型 &别名 = 原名```  
ex:
```cpp
void test()
{
    int a = 10;
    int& b = a;

    cout << a << "\t" << b << endl; // 10 10

    b = 20;
    cout << a << "\t" << b << endl; // 20 20
}
```

## 2.2 引用注意事项
- 引用必须初始化
- 引用在初始化后，**不可更改**  
ex：
```cpp
void test()
{
	int a = 10;
    // int &b; //错误，引用必须初始化
	int& b = a;

	int c = 20;
	b = c; // 赋值操作，而不是更改引用
	cout << &a << "\t" << &b << '\t' << &c << endl; // 可以发现a和b的地址是一样的，只是值都变成了20
}
```

## 2.3 引用做函数参数
**作用**：函数传参时，可以利用引用的技术让形参修饰实参  
**有点**：可以简化指针修改实参  
ex：
```cpp
void swap1(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void swap2(int &a, int &b)
{
	int c = 30;
	int tmp = a;
	a = c;
	b = tmp;
}

void test()
{
	int a = 10;
	int b = 20;

// 	swap1(&a, &b); // 地址传递，形参会修饰实参
	swap2(a, b); // 引用传递，同地址传递，形参也会修饰实参

	cout << "a=" << a << " b=" << b << endl;
}
```
>小结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更清晰简单。

## 2.4 引用做函数返回值
**作用**：引用是可以作为函数的返回值存在的  
**注意**：不要返回局部变量引用  
**用法**：函数调用作为左值  
ex：
```cpp
// 1.不要返回局部变量的引用
int& test1()
{
	int a = 10; // 局部变量存放在四区中的栈区
	return a;
}

// 2.函数的调用可以作为左值
int& test2()
{
	static int a = 10; // 静态变量，存放在全局区，在程序结束后系统释放
	return a;
}

int main()
{
	//int& ref = test1();
	//cout << "ref = " << ref << endl; // 编译器保留输出正确结果
	//cout << "ref = " << ref << endl; // 局部变量内存释放结果错误

	int& ref = test2();
	cout << "ref = " << ref << endl; // 10
	test2() = 100; // 如果函数返回值是引用，这个函数调用可以作为左值
	cout << "ref = " << ref << endl; // 100，因为a的别名是ref2
 
	system("pause");
	return 0;
}
```

## 2.5 引用的本质
**作用**：引用的本质在C++内部实现是一个**指针常量**  
ex：
```cpp
// 发现是引用，转换为 int* const ref = &a
void func(int &ref)
{
	ref = 100;
}

int main()
{
	int a = 10;
	// 自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int& ref = a;

	ref = 20; // 内部发现ref是引用，自动帮我们转换为：*ref = 20；
	cout << "a = " << a << endl; // 20
	cout << "ref = " << ref << endl; // 20

	func(a);
	cout << "a = " << a << endl; // 100
	cout << "ref = " << ref << endl; // 100
 
	system("pause");
	return 0;
}
```
>小结：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了

## 2.6 常量引用
**作用**：常量引用主要用来修饰形参，防止误操作  
在函数形参列表中，可以加**const修饰形参**，防止形参改变实参  
ex：
```cpp
void showValue(const int& val)
{
	// val = 1000; // 不可更改
	cout << "val = " << val << endl;
}

int main()
{
	// int a = 10;
	// int &ref = 10; 错误！！引用必须引用一块合法的内存空间

	// 加上const之后，编译器将代码修改成 int temp = 10; const int &ref = temp;
	const int& ref = 10;
	// ref = 20; // 加入const之后变为只读，不可以修改

	int a = 100;
	showValue(a); // 100

	cout << "a = " << a << endl; // 100

	system("pause");
	return 0;
}
```
>小结：```const```可以修饰：  
变量  
结构体  
常量引用

&nbsp;
# 三、函数提高
>在C++中，函数的形参列表中的形参是可以有默认值的
## 3.1 函数默认参数
**语法**：```返回值类型 函数名 (参数=默认值) {}```  
ex：
```cpp
//如果我们自己传入数据，就用自己的数据，如果没有，那么用默认值
// 注意：
//1.如果某个位置已经有了默认参数，那么从这个位置往后，从左到右必须都有默认值
int func(int a, int b = 20, int c = 30)
{
	return a + b + c;
}

//2.如果函数的声明有了默认参数，函数实现就不能有默认参数
//声明和实现只能有一个默认参数
int func2(int a = 30, int b = 50);
int func2(int a, int b)
{
	return a + b;
}

int main()
{
	cout << func(10) << endl; // 60
	cout << func(10, 30) << endl; // 70
	cout << func2() << endl; // 80

	system("pause");
	return 0;
}
```

## 3.2 函数占位参数
>C++中函数的形参列表可以有占位参数，用来做占位，调用函数时必须填补该位置

语法：```返回值类型 函数名 (数据类型){}```  
在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术  
ex：
```cpp
void func(int a, int)
{
	cout << "func1" << endl;
}

void func2(int a, int =10)
{
	cout << "func2" << endl;
}

int main()
{
	func(10, 10); // func1
	func2(1); // func2
	func2(1); // func2

	system("pause");
	return 0;
}
```

## 3.3 函数重载
### 3.3.1 函数重载概述
**作用**：函数名可以相同，提高复用性  
**函数重载满足条件**：
- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**  
**注意**：函数的返回值不可以作为函数重载的条件
```cpp
//函数重载
//可以让函数名相同，提高复用性
//函数重载的满足条件:
//1.同一个作用域下 2.函数名称相同 3.函数参数类型不同，或者个数不同，或者顺序不同
void func()
{
	cout << "func 的调用" << endl;
}
//个数不同
void func(int a)
{
	cout << "func(int a) 的调用" << endl;
}
//参数类型不同
void func(double a)
{
	cout << "func(double a) 的调用" << endl;
}
//顺序不同
void func(int a, double b)
{
	cout << "func(int a,double b) 的调用" << endl;
}
void func(double a, int b)
{
	cout << "func(double a,int b) 的调用" << endl;
}
//注意事项
//函数的返回值不可以作为函数重载的条件
//int func(double a, int b)
//{
//	cout << "func(double a,int b) 的调用" << endl;
//	return 0;
//}
int main()
{
	func(); // func 的调用
	func(10); // func(int a) 的调用
	func(3.14); // func(double a) 的调用
	func(10, 3.14); // func(int a,double b) 的调用
	func(3.14, 10); // func(double a,int b) 的调用

	system("pause");
	return 0;
}
```
其实**有接收变量**的情况下，**函数的返回值也可以作为函数重载的条件**
```cpp
int func(int a, double b)
{
	cout << "func1" << endl; // 输出func1
	return 0;
}

int func(int a, int b)
{
	cout << "func2" << endl;
	return 0;
}

int main()
{
	int a = func(10, 3.14);

	system("pause");
	return 0;
}
```

### 3.3.2 函数重载注意事项
- 引用作为重载条件
- 函数重载碰到函数默认参数  
ex：
```cpp
// 1.引用作为重载的条件
void func(int& a)
{
	cout << "func(int& a)调用" << endl;
}

void func(const int& a)
{
	cout << "func(const int& a)调用" << endl;
}

// 2.函数重载碰到默认参数
void func2(int a, int b = 10)
{
	cout << "func2(int a, int b = 10)调用" << endl;
}

void func2(int a)
{
	cout << "func2(int a)调用" << endl;
}

int main()
{
	int a = 10;
	func(a); // 输出func(int& a)调用
	func(10); // int &a=10 不合法； const int &a = 10 合法
    // 输出func(const int& a)调用

	//func2(10); // 当函数重载碰到默认参数，出现二义性，报错

	system("pause");
	return 0;
}
```

&nbsp;
# 四、类对象
>C++面向对象的三大特性为：**封装、继承、多态**  
C++认为万事万物都皆为对象，对象上有其属性和行为

ex：
>人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...  
车也可以作为对象，属性有轮胎、方向盘、车灯...，行为有载人、放音乐、放空调...  
具有相同性质的**对象**，我们可以抽象成为**类**，人属于人类，车属于车类

## 4.1 封装
### 4.1.1 封装的意义
>封装是C++面向对象三大特性之一

封装的意义：
- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

意义一：
>在设计类的时候，属性和行为写在一起，表现事物  
语法：```class 类名{访问权限：属性 / 行为};  

ex1：设计一个圆类，求圆的周长
```cpp
#include <iostream>
using namespace std;

const double PI = 3.14;

class Circle
{
	// 访问权限
public: // 公共权限
	// 属性
	int radius;

	// 行为
	double cacluteZC()
	{
		return 2 * radius * PI;
	}

};

int main()
{
	// 通过圆类 创建具体的圆（对象）
	Circle c;
	// 给圆对象的属性进行赋值
	c.radius = 10;

	cout << c.cacluteZC() << endl; // 62.8

	system("pause");
	return 0;
}
```
ex2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号
```cpp
class Student
{
public:
	// 类中的属性和行为 我们统一称为成员
	// 属性 成员属性 成员变量
	// 行为 成员函数 成员方法


	string name;
	int number;

	void showInfo()
	{
		cout << "学生的姓名是：" << name << " 编号为：" << number << endl;
	}
};

int main()
{
	Student s1;
	s1.name = "小葛";
	s1.number = 5332112;
	
	s1.showInfo(); // 学生的姓名是：小葛 编号为：5332112

	system("pause");
	return 0;
}
```

意义二：
>类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：
1. public 公共权限
2. protected 保护权限
3. private 私有权限

ex：
```cpp
#include <iostream>
using namespace std;

// 访问权限：
// 公共权限pubic：	成员 类内可以访问 类外可以访问
// 保护权限protected：	成员 类内可以访问 类外不可以访问 子可以访问父的保护内容
// 私有权限private：		成员 类内可以访问 类外不可以访问 子不可以访问父的私有内容

class Person
{
public:
	// 公共权限
	string m_Name;

protected:
	// 保护权限
	string m_Car;

private:
	// 私有权限
	int m_Password;

public:
	void func()
	{
		m_Car = "拖拉机";
		m_Password = 123456;
		cout << m_Name << " " << m_Car << " " << m_Password << endl; // 李四 拖拉机 123456
	}
};

int main()
{
	// 实例化具体对象
	Person p1;

	p1.m_Name = "李四";
	//p1.m_Car = "奔驰"; // 保护权限，protected成员，不可访问
	//p1.m_Password = 123; // 私有权限，private成员，不可访问
	p1.func();

	system("pause");
	return 0;
}
```

### 4.1.2 struct和class的区别
>在C++中struct和class唯一的区别就在于**默认的访问权限不同**  
在C语言中struct结构体内不可以写函数，但是C++中可以

区别：  
- struct默认权限为公共
- class默认权限为私有
```cpp
class C1
{
	int a; // 默认权限为私有
};

struct C2
{
	int b; // 默认权限为公有
};

int main()
{
	C1 c1;
	c1.a = 5; // 无法访问private成员

	C2 c2;
	c2.b = 1;

	system("pause");
	return 0;
}
```

### 4.1.3 成员属性设置为私有
**优点1**：将所有成员属性设置为私有，可以自己控制读写权限  
**优点2**：对于写权限，我们可以检测数据的有效性  
ex：
```cpp
class Person
{
public:
	void setName(string name)
	{
		m_name = name;
	}

	string getName()
	{
		return m_name;
	}

	int getAge()
	{
		m_Age = 0;
		return m_Age;
	}

	void setAge(int age)
	{
		if (age > 0 || age < 150)
		{
			cout << "输入有误" << endl;
			return;
		}
		m_Age = age;
	}

	void setLover(string Lover)
	{
		m_Lover = Lover;
		cout << m_Lover << endl;
	}


private:
	string m_name; // 姓名 可读可写
	int m_Age; // 年龄 只读
	string m_Lover; // 情人 只写
};

int main()
{
	Person p;
	p.setName("李四");
	cout << p.getName() << endl;
	p.setAge(1000);
	cout << p.getAge() << endl;
	p.setLover("小苍");
	//cout << p.m_Lover << endl; // 只写属性，不可以读取

	system("pause");
	return 0;
}
```
ex1：设计立方体类（Cube）
>求出立方体的面积和体积  
分别用全局函数和成员函数判断两个立方体是否相等
```cpp
//1.创建立方体的类
//2.设计属性
//3.设计行为 获取立方体面积和体积
//4.分别利用全局函数和成员函数 判断两个立方体是否相等
class Cube
{
public:
	double getLength()
	{
		return m_L;
	}

	void setLength(double l)
	{
		m_L = l;
	}

	double getWidth()
	{
		return m_W;
	}

	void setWidth(double w)
	{
		m_W = w;
	}

	double getHeight()
	{
		return m_H;
	}

	void setHeight(double h)
	{
		m_H = h;
	}

	double getArea()
	{
		return (m_H * m_L + m_L * m_W + m_H * m_W) * 2;
	}

	double getVolume()
	{
		return m_H * m_L * m_W;
	}

	// 成员函数
	bool isSame(Cube &c) // 拿面积相比；使用引用就是用原始数据，不会再拷贝出另外一份数据占用内存空间
	{
		if (getArea() == c.getArea())
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool isCompleteSame(Cube &c)
	{
		if (m_L == c.getLength() && m_W == c.getWidth() && m_H == c.getHeight())
		{
			return true;
		}
		else
		{
			return false;
		}
	}

private:
	double m_L;
	double m_W;
	double m_H;
};

// 全局函数
bool isSame(Cube c1, Cube c2)
{
	if (c1.getArea() == c2.getArea())
	{
		return true;
	}
	else
	{
		return false;
	}
}

int main()
{
	Cube c1;
	Cube c2;

	c1.setHeight(2);
	c1.setLength(1);
	c1.setWidth(3);
	cout << c1.getVolume() << endl;
	cout << c1.getArea() << endl;

	c2.setHeight(2);
	c2.setLength(3);
	c2.setWidth(1);
	cout << c2.getVolume() << endl;
	cout << c2.getArea() << endl;

	// 利用成员函数判断
	bool flag1 = c1.isSame(c2);
	if (flag1)
	{
		cout << "两cube面积相等" << endl;
	}
	else
	{
		cout << "面积不相等" << endl;
	}

	bool flag2 = c1.isCompleteSame(c2);
	if (flag2)
	{
		cout << "且两cube完全相等" << endl;
	}
	else
	{
		cout << "但不完全相等" << endl;
	}

	// 利用全局函数判断
	bool flag3 = isSame(c1, c2);

	system("pause");
	return 0;
}
```
ex2：点和圆的关系
>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系
```cpp
#include <iostream>
#include <math.h>
using namespace std;

class Point
{
public:
	double getAxisx()
	{
		return m_x;
	}

	void setAxisx(double x)
	{
		m_x = x;
	}

	double getAxisy()
	{
		return m_y;
	}

	void setAxisy(double y)
	{
		m_y = y;
	}

private:
	double m_x;
	double m_y;
};

class Circle
{
public:
	double getRadius()
	{
		return radius;
	}

	void setRadius(double r)
	{
		radius = r;
	}

	Point getCenter()
	{
		return center;
	}

	void setCenter(double x, double y)
	{
		center.setAxisx(x);
		center.setAxisy(y);
	}

private:
	double radius;
	Point center; // 在类中可以让另一个类 作为本类中的成员
};

void calDistance(Point& p, Circle& c)
{
	double distance = pow(p.getAxisx() - c.getCenter().getAxisx(), 2) + pow(p.getAxisy() - c.getCenter().getAxisy(), 2); // 求幂需要用到math头文件
	double radius = pow(c.getRadius(), 2);

	if (distance == radius)
	{
		cout << "点在圆上" << endl;
	}
	else if (distance > radius)
	{
		cout << "点在圆外" << endl;
	}
	else
	{
		cout << "点在圆内" << endl;
	}
}

int main()
{
	Point p1;
	Circle c1;

	p1.setAxisx(5);
	p1.setAxisy(3);

	c1.setCenter(5, 5);
	c1.setRadius(2);

	calDistance(p1, c1);

	system("pause");
	return 0;
}
```
**分文件编写**:  
point.h
```cpp
#pragma once // 防止头文件重复包含
#include <iostream>
using namespace std;

class Point
{
public:
	double getAxisx(); // 注意声明不需要加{}

	void setAxisx(double x);

	double getAxisy();

	void setAxisy(double y);

private:
	double m_x;
	double m_y;
};
```
point.cpp
```cpp
#include "point.h"

double Point::getAxisx() // 要变成成员函数，需要加上对应类的作用域
{
	return m_x;
}

void Point::setAxisx(double x)
{
	m_x = x;
}

double Point::getAxisy()
{
	return m_y;
}

void Point::setAxisy(double y)
{
	m_y = y;
}
```
circle.h
```cpp
#pragma once // 防止头文件重复包含
#include <iostream>
#include "point.h" // 注意引入头文件，因为用到了Point类
using namespace std;

class Circle
{
public:
	double getRadius();

	void setRadius(double r);

	Point getCenter();

	void setCenter(double x, double y);

private:
	double radius;
	Point center; // 在类中可以让另一个类 作为本类中的成员
};
```
circle.cpp
```cpp
#include "circle.h";

double Circle::getRadius()
{
	return radius;
}

void Circle::setRadius(double r)
{
	radius = r;
}

Point Circle::getCenter()
{
	return center;
}

void Circle::setCenter(double x, double y)
{
	center.setAxisx(x);
	center.setAxisy(y);
}
```
main.cpp
```cpp
#include <iostream>
#include <math.h>
using namespace std;
#include "point.h"
#include "circle.h";

void calDistance(Point& p, Circle& c)
{
	double distance = pow(p.getAxisx() - c.getCenter().getAxisx(), 2) + pow(p.getAxisy() - c.getCenter().getAxisy(), 2);
	double radius = pow(c.getRadius(), 2);

	if (distance == radius)
	{
		cout << "点在圆上" << endl;
	}
	else if (distance > radius)
	{
		cout << "点在圆外" << endl;
	}
	else
	{
		cout << "点在圆内" << endl;
	}
}

int main()
{
	Point p1;
	Circle c1;

	p1.setAxisx(10);
	p1.setAxisy(9);

	c1.setCenter(10,0);
	c1.setRadius(10);

	calDistance(p1, c1);

	system("pause");
	return 0;
}
```

## 4.2 对象的初始化和清理
>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用的时候也会删除一些自己信息数据保证安全  
C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置

### 4.2.1 构造函数和析构函数
对象的**初始化和清理**也是两个非常重要的安全问题
>一个对象或者变量没有初始状态，对其使用后果是未知  
同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

C++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作  
对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**  
**编译器提供的构造函数和析构函数是空实现**(如果你写了就用你的，否则就调用空的)
- 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
- 析构函数：主要作用于对象**销毁前**系统自动调用，执行一些清理工作

**构造函数语法**：```类名(){}```
1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象的时候会自动调用构造，无需手动调用，而且只会调用一次

**析构函数语法**：```~类名(){}```
1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次
```cpp
#include <iostream>
using namespace std;

class Person
{
public: // 调用的话需要在public作用域下才能访问到
	Person()
	{
		cout << "Person构造函数调用" << endl;
	};

	~Person()
	{
		cout << "Person析构函数调用" << endl;
	};
};

void test1()
{
	Person p1; // 在栈上的数据，test1执行完毕后，会释放这个对象
}

int main()
{
	//test1(); // 构造和析构都会被调用，因为函数执行完后就被释放
	Person p2; // 只有构造会被调用，因为还没有被释放

	system("pause");
	return 0; // 程序结束后p2才被释放
}
```

### 4.2.2 构造函数的分类及调用
两种分类方式：
>按参数分为：有参构造和无参构造  
按类型分为：普通构造和拷贝构造

三种调用方式：
> - 括号法
> - 显示法
> - 隐式转换法

ex：
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	// 构造函数
	Person()
	{
		cout << "Person 无参构造函数的调用" << endl;
	}
	Person(int a)
	{
		age = a;
		cout << "Person 有参构造函数的调用" << endl;
	}
	// 拷贝构造函数
	Person(const Person &p)
	{
		// 将传入的人身上的所有属性，拷贝到自己身上
		age = p.age;
		cout << "Person 拷贝构造函数的调用" << endl;
	}

	~Person()
	{
		cout << "Person 析构函数的调用" << endl;
	}

	int age;
};

void test()
{
	// 1.括号法
	//Person p; // 默认构造函数
	//Person p2(10); // 有参构造函数
	//Person p3(p2); // 拷贝构造函数
	// 注意：调用默认构造函数不要加（）因为下面这行代码，编译器会认为是一个函数的声明就像void func()
	//Person p1();

	// 2.显示法
	Person p1;
	Person p2 = Person(10); // 有参构造函数
	Person p3 = Person(p2); // 拷贝构造函数

	Person(10); // 等号右侧单独拿出来叫匿名对象	特点：当前行执行结束后，系统会立即回收掉匿名对象
	cout << "匿名对象Person(10)被回收了哈哈哈" << endl;
	// 注意：不要利用拷贝构造函数初始化匿名对象	编译器会认为Person(p3)等价于Person p3; 即对象声明
	//Person(p3);

	// 3.隐式转换法
	Person p4 = 10; // 相当于写了Person p4 = Person(10); 有参构造
	Person p5 = p4; // 拷贝构造
}

int main()
{
	test();

	system("pause");
	return 0; 
}
```

### 4.2.3 拷贝构造函数调用时机
C++中拷贝构造函数调用时机通常有三种情况
- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象  
ex：
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	// 构造函数
	Person()
	{
		cout << "Person 无参构造函数的调用" << endl;
	}
	Person(int a)
	{
		age = a;
		cout << "Person 有参构造函数的调用" << endl;
	}
	// 拷贝构造函数
	Person(const Person &p)
	{
		age = p.age;
		cout << "Person 拷贝构造函数的调用" << endl;
	}

	~Person()
	{
		cout << "Person 析构函数的调用" << endl;
	}

	int age;
};

void test01()
{
	Person p1(20);
	Person p2(p1);

	cout << p1.age << " " << p2.age << endl;
}

// 2.值传递的方式，注意函数形参被赋值相当于拷贝构造
void doWork(Person p)
{

}

void test02()
{
	Person p;
	doWork(p);
}

// 3.值方式返回局部对象，注意返回的是Person类
Person doWork2()
{
	Person p;
	cout << &p << endl;
	return p; // 这里返回的是拷贝后的p，而不是上面初始化的p
}

void test03()
{
	Person p = doWork2();
	cout << &p << endl;
}

int main()
{
	//test01();
	//test02();
	test03();

	system("pause");
	return 0; 
}
```

### 4.2.4 构造函数的调用规则
默认情况下，C++编译器至少给一个类添加三个函数
1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：
- 如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

ex：
```cpp
class Person
{
public:
	//// 构造函数
	//Person()
	//{
	//	cout << "Person 无参构造函数的调用" << endl;
	//}
	Person(int a)
	{
		age = a;
		cout << "Person 有参构造函数的调用" << endl;
	}
	// 拷贝构造函数
	//Person(const Person &p)
	//{
	//	age = p.age;
	//	cout << "Person 拷贝构造函数的调用" << endl;
	//}

	~Person()
	{
		cout << "Person 析构函数的调用" << endl;
	}

	int age;
};

void test01()
{
	Person p; // 此时如果用户提供有参构造，编译器不会自己提供默认构造，但会提供拷贝构造
	Person p1(3); // 如果用户仅提供拷贝构造，编译器不会提供其他构造函数
	Person p2(p1); // 如果用户仅提供拷贝构造，这样初始化会报错 想要初始化只能Person p2 = Person(p2)
}

int main()
{
	test01();

	system("pause");
	return 0; 
}
```

### 4.2.5 深拷贝与浅拷贝
>深浅拷贝是面试经典问题，也是常见的一个坑

**浅拷贝**：简单的赋值拷贝操作  
**深拷贝**：在堆区重新申请空间，进行拷贝操作
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	Person()
	{
		cout << "Person 的默认构造" << endl;
	}

	Person(int age, int height)
	{
		p_age = age;
		p_height = new int(height);
		cout << "Person 的有参构造" << endl;
	}

	// 如果有指针存在，使用默认编译器的拷贝构造函数的话只能进行浅拷贝。当两个变量指向同一块儿内存时，在析构函数操作时会造成堆区内容的重复释放（第一次已经将该块内存删除掉了所以第二次找不到）
	Person(const Person &p)
	{
		cout << "Person 拷贝构造调用" << endl;
		p_age = p.p_age;

		// 浅拷贝 p_height = p.p_height; 是编译器默认实现的代码
		// 深拷贝，用new在堆区开辟一块儿新的内存
		p_height = new int (*p.p_height); // *用来解引用
	}

	~Person()
	{
		if (p_height != NULL)
		{
			delete p_height;
			p_height = NULL;
		}
		cout << "Person 析构函数调用" << endl;
	}

	int* p_height;
	int p_age;
};

void test1()
{
	Person p1(1,180);
	cout << "p1的年龄为：" << p1.p_age << " p1的身高为：" << *p1.p_height << endl;

	Person p2(p1); // 因为在栈区，先进后出，所以先调用p2的析构函数
	cout << "p2的年龄为：" << p2.p_age << " p2的身高为：" << *p2.p_height << endl;
}

int main()
{
	test1();

	system("pause");
	return 0;
}
```
>小结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

### 4.2.6 初始化列表
**作用**：C++提供了初始化列表语法，用来初始化属性  
**语法**：```构造函数(): 属性1(值1)，属性2(值2)，... {}```
```cpp
class Person
{
public:
	// 传统初始化操作
	//Person(int a, int b, int c)
	//{
	//	p_a = a;
	//	p_b = b;
	//	p_c = c;
	//}

	// 初始化列表初始化属性
	Person(int a, int b, int c) : p_a(a), p_b(b), p_c(c)
	{

	}

	int p_a, p_b, p_c;
};

int main()
{
	Person a(1, 2, 3);
	cout << a.p_a << a.p_b << a.p_c << endl; // 123

	system("pause");
	return 0;
}
```

### 4.2.7 类对象作为类成员
>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员

例如：
```cpp
class A {}
class B
{
	A a;
}
```
>B类中有对象A作为成员，A为对象成员  
那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

ex：
```cpp
#include <iostream>
using namespace std;

class Phone
{
public:
	Phone(string phone)
	{
		ph_name = phone;
		cout << "Phone 构造函数的调用" << endl;
	}

	~Phone()
	{
		cout << "Phone 析构函数的调用" << endl;
	}

	string ph_name;
};

class Person
{
public:
	// 这里之所以phone可以传string类型是因为隐式转换法：Phone p_phone = phone 等价于 Phone p_phone = Phone(phone)有参构造;
	Person(string name, string phone) :p_name(name), p_phone(phone)
	{
		cout << "Person 构造函数的调用" << endl;
	}

	~Person()
	{
		cout << "Person 析构函数的调用" << endl;
	}

	string p_name;
	Phone p_phone;
};
// 当其它类对象作为本类成员，构造时候先构造类对象，再构造自身。析构与构造相反
void test()
{
	Person p("小哥", "apple14");
	cout << p.p_name << "有" << p.p_phone.ph_name << endl;
}

int main()
{
	test();

	system("pause");
	return 0;
}
```
输出
```
Phone 构造函数的调用
Person 构造函数的调用
小哥有apple14
Person 析构函数的调用
Phone 析构函数的调用
```
>小结：当其它类对象作为本类成员，构造时候先构造类对象，再构造自身。析构与构造相反（栈）。

### 4.2.8 静态成员
>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：
- 静态成员变量
	- 所有对象共享同一份数据
	- 在编译阶段分配内存
	- 类内声明，类外初始化
- 静态成员函数
	- 所有对象共享同一个函数
	- 静态成员函数只能访问静态成员变量

ex1：静态成员变量
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	// 类内初始化
	static int m_A; // 静态成员变量

private:
	static int m_B; // 静态成员变量也是有访问权限的
};
// 类外定义
int Person::m_A = 10; // 非静态数据不能在类的外部定义
int Person::m_B = 10;

void test()
{
	// 1.通过对象
	Person p1;
	p1.m_A = 100;
	cout << p1.m_A << endl; // 100

	Person p2;
	p2.m_A = 200;
	cout << "p1:" << p1.m_A << endl; // 200 共享同一份数据，所以100被200覆盖
	cout << "p2:" << p2.m_A << endl; // 200

	// 2.通过类名
	cout << "m_A = " << Person::m_A << endl; // 200
	//cout << "m_B = " << Person::m_B << endl; // 私有对象不可访问
}

int main()
{
	test();

	system("pause");
	return 0;
}
```
ex2：静态成员函数
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	static void func()
	{
		m_a = 10; // 静态函数访问静态成员变量
		// 静态函数是独立存在的，发生在对象实例化之前，所以找不到指定的m_b
		//m_b = 20; // 静态成员函数不可以访问非静态成员变量，因为无法区分到底是哪个实例化对象的m_b
		cout << "static void func调用" << endl;
	}
	static int m_a;
	int m_b;

private:
	// 静态成员一样有访问权限
	static void func2()
	{
		cout << "static void func2的调用" << endl;
	}
};
int Person::m_a = 0; // 类内定义后必须类外初始化

void test()
{
	Person p;
	p.func();
	cout << p.m_a << endl;

	Person p1;
	p1.func(); // 所有对象共享同一个函数，在p的操作基础上做赋值
	Person::func(); 
	//Person::func2(); // 类外访问不到私有的静态成员函数
}

int main()
{
	test();

	system("pause");
	return 0;
}
```

## 4.3 C++对象模型和this指针
### 4.3.1 成员变量和成员函数分开存储
>在C++中，类内的成员变量和成员函数分开存储  
只有非静态成员变量才属于类的对象上

ex：
```cpp
// 成员变量和成员函数是分开存储的
class Person
{
	// 如果是空类型的话 实例化对象占1内存
public:
	int a; // 非静态成员变量 属于类的对象上
	static int b; // 静态成员变量 不属于类对象上
	void func1() {}; // 非静态成员函数 不属于类对象上
	static void func2() {}; // 静态成员函数 不属于类对象上
};

void test()
{
	Person p;
	p.a = 3; // 测试类内初始化
	cout << (p.a == 3) ? 1 : 2; // 1
	cout << sizeof(p) << endl; // 4
}
```

### 4.3.2 this指针概念
>上述我们得知在C++中成员变量和成员函数是分开存储的  
每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码  
那么问题是：这一块代码是如何区分是哪个对象调用自己的呢？  
C++通过提供特殊的对象指针，this指针来解决上述问题。即**this指针指向被调用的成员函数所属的对象**  
this指针是隐含在每一个非静态成员函数内的一种指针  
this指针不需要定义，直接使用即可

**this指针的用途**：
- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可以使用return *this
```cpp
class Person
{
public:
	Person(int age)
	{
		// this指针指向的是被调用的成员函数所属的对象p
		this->age = age;
	}
	Person& personAddAge(Person& p)
	{
		this->age += p.age;
		// this指针指向p2的指针，而*this指向的就是p2这个对象本体
		return *this; // 输出的是p2，加引用的话一直是p2本体，若不加引用则为拷贝构造出来的新对象
	}

	int age;
};

void test()
{
	// 1.解决名称冲突
	// 2.返回对象本身用*this
	Person p1(10);
	Person p2(p1);
	// 链式编程思想
	p2.personAddAge(p1).personAddAge(p1).personAddAge(p2);
	cout << p2.age << endl;
}
```

### 4.3.3 空指针访问成员函数
C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针  
如果用到this指针，需要加以判断保证代码的健壮性  
ex：
```cpp
class Person
{
public:
	void showClassName()
	{
		cout << "this is Person class" << endl;
	}

	void showPersonAge()
	{
		// 报错原因是因为传入的指针为NULL
		if (this == NULL)
		{
			return;
		}
		cout << "age =" << m_Age << endl;
	}

	int m_Age;
};

void test()
{
	Person *p = NULL;
	p->showClassName(); // 空指针 可以调用成员函数
	p->showPersonAge(); // 但是如果成员函数用到了this指针，就会报错
}
```

### 4.3.4 const修饰成员函数
**常函数**：
- 成员函数后加const后我们称这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象**：
- 声明对象前加const称该对象为常对象
- 常对象只能调用常函数

ex：
```cpp
class Person
{
public:
	void showPerson() const
	{
		//this->m_A = 10; 在常函数内this指针不可以修改指针的指向
		//this = NULL;
		this->m_B = 10;
	}

	void func()
	{

	}

	int m_A;
	mutable int m_B; // 特殊变量 即使在常函数中也可以修改这个值
};

void test1()
{
	Person p;
	p.showPerson();

}

// 常对象
void test2()
{
	const Person p; // 在对象前加const，变为常对象
	//p.m_A = 10;
	p.m_B = 100; // mutable的作用

	// 常对象只能调用常函数
	p.showPerson();
	//p.func(); // 常对象不可以调用普通的成员函数，因为普通成员函数可以修改属性的值
}
```

## 4.4 友元
举个例子，生活中你的家里有客厅(Public), 有你的我是(Private)  
客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去  
但是呢，你也可以允许你的好朋友进去。  
在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术  
友元的目的就是让一个函数或者类 访问另一个类中私有成员  
友元的关键字为**friend**  
友元的三种实现：
- 全局函数做友元
- 类做友元
- 成员函数做友元

### 4.4.1 全局函数做友元
```cpp
class Building
{
	friend void goodGay(Building& b); // goodGay全局函数是Building的友元，可以访问Builiding中的私有成员
public:
	Building()
	{
		bed = "席梦思";
		desk = "宜家";
	}

private:
	string bed;
	string desk;
};
// 全局函数
void goodGay(Building& b)
{
	cout << b.bed << endl; // 席梦思
	cout << b.desk << endl; // 宜家
}


void test01()
{
	Building b;
	goodGay(b);
}
```

### 4.4.2 类做友元
ex：
```cpp
#include <iostream>
using namespace std;

class Building; // 相当于提前对类的声明！！否则Building *b会报错
class GoodGay
{
public:
	GoodGay();
	void visit();

	Building* b;
};

class Building
{
	friend class GoodGay;
public:
	Building();

	string bedroom;

private:
	string desk;
};

// 类外写成员函数
Building::Building()
{
	this->bedroom = "席梦思";
	this->desk = "宜家";
}

GoodGay::GoodGay()
{
	this->b = new Building;
}

void GoodGay::visit()
{
	cout << b->bedroom << endl;
	// 定义友元才能访问私有属性
	cout << b->desk << endl;
}

void test01()
{
	GoodGay g;
	g.visit();
}


int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 4.4.3 成员函数做友元
ex：
```cpp
class Building; // 相当于提前对类的声明！！否则Building *b会报错
class GoodGay
{
public:
	GoodGay();
	void visit1(); // 让visit1函数可以访问Building的私有成员
	void vist2(); // 让visit2函数不可以访问Building的私有成员

	Building* b;
};

class Building
{
	friend void GoodGay::visit1(); // 告诉编译器GoodGay类下的visit成员函数作为本类的好朋友可以访问私有成员
public:
	Building();

	string bedroom;

private:
	string desk;
};
```

## 4.5 运算符重载
**运算符重载概念**：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
### 4.5.1 加号运算符重载
**作用**：实现两个自定义数据类型相加的运算  
对于内置数据类型，编译器知道如何进行运算，不可能改变  
通过自己写成员函数，实现两个对象相加属性后返回新的对象  
编译器给起了一个通用名称，通过成员函数重载+号，或通过全局函数重载+号
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	Person(int height, int weight)
	{
		this->height = height;
		this->weight = weight;
	}
	// 1.成员函数重载+号
	//Person operator+(Person &p)
	//{
	//	Person temp(this->height + p.height, this->weight + p.weight);
	//	return temp;
	//}

	int height;
	int weight;
};

// 2.全局函数重载+号
Person operator+(Person& p1, Person& p2)
{
	Person temp(p1.height + p2.height, p1.weight + p2.weight);
	return temp;
}

// 函数重载的版本
Person operator+(Person& p1, int num)
{
	Person temp(p1.height + num, p1.weight + num);
	return temp;
}

void test01()
{
	Person p1(180, 60);
	Person p2(150, 40);
	Person p3 = p1 + p2;
	cout << p3.height << " " << p3.weight << endl; // 330 100

	// 运算符也可以发生函数重载
	Person p4 = p1 + 10; // person+int
	cout << p4.height << " " << p4.weight << endl; // 190 70
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 4.5.2 左移运算符重载
**作用**：可以输出自定义数据类型
```cpp
#include <iostream>
using namespace std;

class Person
{
	friend ostream& operator<<(ostream& cout, Person& p);
public:
	Person(int a, int b)
	{
		height = a;
		weight = b;
	}

private:
	// 利用成员函数重载，左移运算符 p.operator<<(cout) 简化版本 p << cout;
	// 不会利用成员函数重载 << 运算符，因为无法实现cout在左侧
	//void operator<<(cout)
	//{

	//}
	int height;
	int weight;
};

// 全局函数实现左移重载
// ostream对象只能有一个，所以不能复制，只能引用。
// cout << ... << endl之前返回值要用ostream对象，所以函数return返回值用ostream
ostream &operator<<(ostream& cout, Person& p)
{
	cout << p.height << " " << p.weight << endl;
	return cout;
}

void test01()
{
	Person p1(30, 3);

	cout << p1 << endl;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：重载左移运算符配合友元可以实现输出自定义数据类型

### 4.5.3 递增运算符重载
**作用**：通过重载递增运算符，实现自己的整形数据  
ex：
```cpp
#include <iostream>
using namespace std;

class Person
{
	friend ostream& operator<<(ostream& cout, Person p);
public:
	Person(int a)
	{
		this->m_age = a;
	}

	// 前置++
	Person& operator++() // 链式思想 返回引用是为了一直对一个数据进行递增操作
	{
		// 先++
		this->m_age++;
		// 再将自身返回
		return *this;
	}

	// 后置++
	// int代表占位参数 可以用来区分前置和后置（编译器这个大聪明自己能区分）
	Person operator++(int) // 局部对象，操作完后内存释放，如果使用引用是非法操作
	{
		Person temp = m_age;
		m_age++;
		return temp;
	}

private:
	int m_age;
};

ostream &operator<<(ostream& cout, Person p)
{
	cout << p.m_age;
	return cout;
}

void test01()
{
	Person p(10);
	cout << p << endl; // 10
	cout << ++p << endl; // 11
	// cout << ++(++p) << endl; // 前置递增可做链式操作
	cout << p++ << endl; // 11 // 后置递增不能做链式运算
	cout << p << endl; // 12
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：前置递增返回引用，后置递增返回值

### 4.5.4 赋值运算符重载
C++编译器至少给一个类添加4个函数  
1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符operator=，对属性进行值拷贝

如果类中属性指向堆区，做赋值操作也会出现深浅拷贝问题  
ex：
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	Person(int a)
	{
		// 将年龄数据开辟到堆区
		age = new int(a);
	}

	// 重载赋值运算符
	Person& operator=(Person& p) // 此处引用传回本体，否则会使用默认的拷贝构造副本（相同值）再次重复调用析构函数重复释放堆区引发异常。
	{
		if (this->age != NULL)
		{
			delete this->age;
			this->age = NULL;
		}
		// 编译器提供的代码是浅拷贝
		// age = p.age;

		// 提供深拷贝 解决浅拷贝问题
		this->age = new int(*p.age);

		// 返回自身 链式对象思想
		return *this;
	}

	~Person()
	{
		if (this->age != NULL)
		{
			delete this->age;
			this->age = NULL;
		}
	}

	int *age; // 此处定义指针！
};

void test01()
{
	Person p1(3);
	Person p2(6);
	Person p3(9);

	p3 = p2 = p1;
	cout << *p3.age << " " << *p2.age << " " << *p1.age << endl; // 3 3 3

}

int main()
{
	test01();
	//int a = 10;
	//int b = 20;
	//int c = 30;

	//c = b = a;

	//cout << c << " " << b << " " << a << endl; // 10 10 10

	system("pause");
	return 0;
}
```

### 4.5.5 关系运算符重载
**作用**：重载关系运算符，可以让两个自定义类型对象进行对比操作  
ex：
```cpp
#include <iostream>
using namespace std;

class Person
{
public:
	Person(int age, int height)
	{
		this->age = age;
		this->height = height;
	}

	bool operator==(Person &p)
	{
		if (this->age == p.age && this->height == p.height)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Person& p)
	{
		if (this->age == p.age && this->height == p.height)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	int age;
	int height;
};

void test01()
{
	Person p1(3, 10);
	Person p2(3, 10);

	cout << (p1 == p2) << endl;
	cout << (p1 != p2) << endl;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 4.5.6 函数调用运算符重载
- 函数调用运算符()也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活

ex：
```cpp
#include <iostream>
using namespace std;

class MyString
{
public:
	void operator()(string s)
	{
		cout << s << endl;
	}
};

class MyAdd
{
public:
	void operator()(int a, int b)
	{
		cout << a + b << endl;
	}
};

void test01()
{
	// 重载的（）操作符 也称为仿函数
	MyString s;
	s("Fuck Rory");
}

void test02()
{
	MyAdd madd;
	madd(3, 4);
	// 匿名对象调用 MyAdd()相当于初始化默认构造
	MyAdd()(3, 5);
}

int main()
{
	test01();
	test02();

	system("pause");
	return 0;
}
```

## 4.6 继承
**继承是面向对象三大特性之一**  
有些类与类之间存在特殊的关系，如动物类下有猫与狗类，猫与狗类下又有不同的品种类  
定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性  
这个时候我们就可以考虑利用继承的技术，减少重复代码

### 4.6.1 继承的基本语法
例如我们看到很多网站中，有公共的头部，底部，甚至左侧列表，只有中心内容不同  
接下俩分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处  
**普通实现**：
```cpp
//Java页面
class Java 
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "JAVA学科视频" << endl;
	}
};
//Python页面
class Python
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};
//C++页面
class CPP 
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
	void content()
	{
		cout << "C++学科视频" << endl;
	}
};

void test01()
{
	//Java页面
	cout << "Java下载视频页面如下： " << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "--------------------" << endl;

	//Python页面
	cout << "Python下载视频页面如下： " << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout << "--------------------" << endl;

	//C++页面
	cout << "C++下载视频页面如下： " << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();
}

int main() {
	test01();
    
	system("pause");
	return 0;
}
```
**继承实现**：  
语法：```class A : public B;```
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	void header()
	{
		cout << "首页、公开课、登录、注册。。。（公共头部）" << endl;
	}

	void footer()
	{
		cout << "帮助中心、交流合作、站内地图。。。（公共底部）" << endl;
	}

	void left()
	{
		cout << "Java、Python、C++。。。（公共分类列表）" << endl;
	}
};

class Java :public Base
{
public:
	void content()
	{
		cout << "Java学科视频" << endl;
	}
};

class Python :public Base
{
public:
	void content()
	{
		cout << "Python学科视频" << endl;
	}
};

class CPP :public Base
{
public:
	void content()
	{
		cout << "CPP学科视频" << endl;
	}
};

void test01()
{
	cout << "Java下载视频页面如下：" << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "----------------------------" << endl;

	cout << "Python下载视频页面如下：" << endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout << "----------------------------" << endl;

	cout << "C++下载视频页面如下：" << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
继承的好处：可以减少重复的代码 

```class A : public B;```  
A类称为子类 或 派生类  
B类称为父类 或 基类  
**派生类中的成员，包含两大部分**：  
一类是从**基类继承**过来的，一类是自己增加的成员。  
从基类继承过来的表现其共性，而新增的成员体现了其个性

### 4.6.2 继承方式
**继承的语法**：```class 子类：继承方式 父类```  
**继承方式一共有三种**：
- 公共继承
- 保护继承
- 私有继承
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	int B_a;
protected:
	int B_b;
private:
	int B_c;
};

// 公共继承
class Son1 : public Base
{
public:
	void func()
	{
		B_a; // 父类中的公共成员 到子类仍然是公共权限
		B_b; // 父类中的保护成员 到子类仍然是保护权限
		//B_c; // 父类中的私有成员 子类访问不到
	}
};

void myClass()
{
	Son1 s1;
	s1.B_a; // 对象只能访问到公共权限
}

// 保护继承
class Son2 : protected Base
{
public:
	void func()
	{
		B_a; // 父类中公共成员 到子类变为保护权限
		B_b; // 父类中的保护成员 到子类变为保护权限
		//B_c; // 父类中私有成员 子类访问不到
	}
};

void myClass2()
{
	Son2 s2;
	//s2.B_a; // B_a变为保护权限 因此类外访问不到
	//s2.B_b; // B_b变为保护权限 不可访问
}

// 私有继承
class Son3: private Base
{
	void func()
	{
		B_a; // 父类中的公共成员 到子类变为私有权限
		B_b; // 父类中保护成员 到子类变为私有权限
		//B_c; // 父类中公共成员 到子类访问不到
	}
};

class GrandSon3 : public Son3
{
public:
	void func()
	{
		// Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到
		//B_a;
		//B_b;
		//B_c;
	}
};

int main()
{
	system("pause");
	return 0;
}
```
>小结：私有权限都不可以继承，其他权限满足就近原则

### 4.6.3 继承中的对象模型
**问题**：从父亲继承过来的成员，哪些属于子类对象中？  
ex：
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	int a;
protected:
	int b;
private:
	int c; // 私有成员只是被隐藏了，但是还是会继承下去
};

// 利用开发人员命令提示工具查看对象模型 输出：
// class Son       size(16):
//+-- -
//0 | +-- - (base class Base)
//0      | | a
//4      | | b
//8      | | c
//| +-- -
//12 | d
//+ -- -
class Son : public Base
{
public:
	int d;
};

void test01()
{
	Son s;
	// 父类中所有非静态成员属性都会被子类继承下去
	// 父类中的私有成员属性 是被编译器给隐藏了 因此访问不到 但确实被继承下去了（在内存中）
	cout << sizeof(Son) << endl; // 16
	cout << sizeof(s) << endl; // 16
}

int main()
{
	test01();
}
```
>小结：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到

### 4.6.4 继承中构造和析构的顺序
子类继承父类后，当创建子类对象，也会调用父类的构造函数  
**问题**：父类和子类的构造和析构顺序是谁先谁后？  
ex：
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	Base()
	{
		cout << "Base的构造函数" << endl;
	}

	~Base()
	{
		cout << "Base的析构函数" << endl;
	}
};

class Son : Base
{
public:
	Son()
	{
		cout << "Son的构造函数" << endl;
	}

	~Son()
	{
		cout << "Son的析构函数" << endl;
	}
};

void test01()
{
	// 继承中的构造和析构顺序如下：
	// 先构造父类，再构造子类，析构的顺序与构造顺序相反
	Son s;
}

int main()
{
	test01();
}
```
输出
```
Base的构造函数
Son的构造函数
Son的析构函数
Base的析构函数
```

### 4.6.5 继承同名成员处理方式
问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？  
- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域  
ex：
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	Base()
	{
		B_a = 100;
	}

	void func()
	{
		cout << "Base - func调用" << endl;
	}

	void func(int a)
	{
		cout << "Base - func(int a)调用" << endl;
	}

public:
	int B_a;
};

class Son : public Base
{
public:
	Son()
	{
		B_a = 200;
	}

	void func()
	{
		cout << "Son - func调用" << endl;
	}

public:
	int B_a;
};

void test01()
{
	Son s;
	cout << s.B_a << endl; // 200
	s.func(); // Son - func调用
	//s.func(1); // 此时会报错。因为如果子类出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数

	cout << s.Base::B_a << endl;
	s.Base::func();
	s.Base::func(10); // 如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域
}

int main()
{
	test01();
}
```
输出
```
200
Son - func调用
100
Base - func调用
Base - func(int a)调用
```
总结：  
1. 子类对象可直接访问到子类中同名成员
2. 子类对象加**作用域**可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

### 4.6.6 继承同名静态成员处理方式
问题：继承中同名的静态成员再子类对象上如何进行访问？
静态成员和非静态成员出现同名，处理方式一致
- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

ex：
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	static void func()
	{
		B_a += 10;
		cout << "Base - static void func()" << endl;
	}
	static void func(int a)
	{
		B_a += a;
		cout << "Base - static void func(int a)" << endl;
	}

	static int B_a;
};
int Base::B_a = 10;

class Son : public Base
{
public:
	static void func()
	{
		B_a += 10;
		cout << "Son - static void func()" << endl;
	}
	static int B_a;
};
int Son::B_a = 20;

// 同名成员属性
void test01()
{
	// 通过对象访问
	Son s;
	cout << s.B_a << endl;
	cout << s.Base::B_a << endl;
	
	// 通过类名访问
	cout << Son::B_a << endl;
	// 第一个::代表通过类名方式访问 第二个::代表访问父类作用域下
	cout << Son::Base::B_a << endl;
}

// 同名成员函数
void test02()
{
	Son s;
	s.func();
	s.Base::func();
	cout << s.B_a << endl;
	cout << s.Base::B_a << endl;

	Son::func();
	Son::Base::func();
	// 子类出现和父类同名静态成员函数，也会隐藏父类中所有同名成员函数
	// 如果像访问父类中被隐藏同名成员，需要加作用域
	Son::Base::func(100);
	cout << s.B_a << endl;
	cout << s.Base::B_a << endl; // 子类和父类的静态成员变量是分开运算的
}

int main()
{
	test01();
	test02();
}
```
>小结：  
同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

### 4.6.7 多继承语法
C++允许**一个类继承多个类**  
语法：```class 子类：继承方式 父类1，继承方式 父类2...```  
多继承可能会引发父类中有同名成员出现，需要加作用域区分  
**C++实际开发中不建议用多继承**  
ex：
```cpp
#include <iostream>
using namespace std;

class Base1
{
public:
	Base1()
	{
		B_a = 100;
	}

public:
	int B_a;
};

class Base2
{
public:
	Base2()
	{
		B_a = 200;
	}

public:
	int B_a;
};

class Son : public Base1, public Base2
{
public:
	Son()
	{
		B_a = 30;
		B_b = 40;
	}
	int B_a;
	int B_b;
};

// 多继承容易产生成员同名的情况
// 通过使用类名作用域可以区分调用哪一个基类的成员
void test01()
{
	Son s;
	cout << sizeof(s) << endl; // 16
	cout << s.B_a << endl; // 30
	cout << s.Base1::B_a << endl; // 100
	cout << s.Base2::B_a << endl; // 200
}


int main()
{
	test01();
}
```
>小结：  
多继承中如果父类出现了同名情况，子类使用时要加作用域

### 4.6.8 菱形继承
菱形继承概念：  
两个派生类继承同一个基类  
又有某个类同时继承着两个派生类  
这种继承被称为菱形继承，或者钻石继承  
**小案例：**动物类下有羊和驼两个派生类，而羊驼又继承这两个派生类  
**菱形继承问题**：  
1. 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性  
2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以

ex：
```cpp
#include <iostream>
using namespace std;

// 动物类
class Animal
{
public:
	int age;
};

// 利用虚继承 解决菱形继承问题
// 继承之前 加上关键字virtual变为虚继承
// Animal类称为 虚基类

// 羊类
class Sheep : virtual public Animal {};
// 驼类
class Tuo : virtual public Animal {};
// 羊驼类
class SheepTuo : public Sheep, public Tuo {};

void test01()
{
	SheepTuo sp;
	sp.Sheep::age = 100;
	sp.Tuo::age = 200;

	// 当菱形继承，两个父类拥有相同的数据，需要加以作用域区分
	cout << sp.Sheep::age << endl; // 200  如果不加virtual输出100
	cout << sp.Tuo::age << endl; // 200 如果不加virtual输出200

	// 这份数据我们知道 只有一份就可以了，菱形继承导致数据有两份，资源浪费
	cout << sp.age << endl; // 200
}


int main()
{
	test01();
}
```
总结：  
- 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
- 利用虚继承可以解决菱形继承问题：使用虚指针vptr占位

## 4.7 多态
### 4.7.1 多态的基本概念
**多态是C++面向对象三大特性之一**  
多态分为两类
- 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

**静态多态和动态多态区别**：
- 静态多态的函数地址早绑定-编译阶段确定函数地址
- 动态多态的函数地址晚绑定-运行阶段确定函数地址

ex：
```cpp
#include <iostream>
using namespace std;

class Animal
{
public:
	// Speak函数就是虚函数
	// 函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用
	virtual void speak()
	{
		cout << "动物在说话" << endl;
	}
};

class Cat : public Animal
{
public:
	void speak()
	{
		cout << "小猫说话" << endl;
	}
};

class Dog : public Animal
{
public:
	void speak()
	{
		cout << "小狗说话" << endl;
	}
};

// 地址早绑定 在编译阶段确定函数地址	父类不加virtual cat.Dospeak会调用父类
// 如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定。父类加virtual cat.Dospeak会调用子类

// 动态绑定满足条件
// 1. 继承
// 2. 子类要重写父类的虚函数
// 多态使用：
// 父类指针或引用指向子类对象

void Dospeak(Animal& animal) // Animal &animal = cat; 父类指针或引用指向子类对象
{
	animal.speak();
}

void test1()
{
	Cat cat;
	Dospeak(cat); // 小猫说话

	Dog dog;
	Dospeak(dog); // 小狗说话
}

int main()
{
	test1();
}
```
总结：  
多态满足条件
- 有继承关系
- 子类重写父类中的虚函数

多态使用条件
- 父类指针或引用指向子类对象

**重写**：函数返回值类型 函数名 参数列表 完全一致称为重写 (子类重写父类中的虚函数)

### 4.7.2 多态案例一-计算器类
**案例描述**：  
分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类  
**多态的优点**：
- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展以及维护

ex：
```cpp
#include <iostream>
using namespace std;

//普通实现
//class Calculator {
//public:
//	int getResult(string oper)
//	{
//		if (oper == "+") {
//			return m_Num1 + m_Num2;
//		}
//		else if (oper == "-") {
//			return m_Num1 - m_Num2;
//		}
//		else if (oper == "*") {
//			return m_Num1 * m_Num2;
//		}
//		//如果要提供新的运算，需要修改源码
//		//在真实开发中 提出 开闭原则
//		//开闭原则：对扩展进行开放，对修改进行关闭
//	}
//public:
//	int m_Num1;
//	int m_Num2;
//};

// 多态实现
// 抽象计算器类
// 多态优点：代码组织结构清晰，可读性强，利于前期的扩展以及维护
class Calculator
{
public:
	virtual int func()
	{
		return 0;
	}

	int a;
	int b;
};

class AddCal : public Calculator
{
public:
	int func()
	{
		return a + b;
	}
};

class SubCal : public Calculator
{
public:
	int func()
	{
		return a - b;
	}
};

class MulCal : public Calculator
{
public:
	int func()
	{
		return a * b;
	}
};

// 可扩展任意计算器功能

void test1()
{
	Calculator* ac = new AddCal; // 这里注意要用父类指针 指向子类对象
	ac->a = 10;
	ac->b = 10;
	cout << ac->a << "+" << ac->b << " = " <<  ac->func() << endl;
	delete ac; // 用完了记得销毁
	
	ac = new SubCal;
	ac->a = 10;
	ac->b = 10;
	cout << ac->a << "-" << ac->b << " = " << ac->func() << endl;
	delete ac; // 用完了记得销毁

	ac = new MulCal;
	ac->a = 10;
	ac->b = 10;
	cout << ac->a << "*" << ac->b << " = " << ac->func() << endl;
	delete ac; // 用完了记得销毁
}

int main()
{
	test1();
}
```
>小结：C++开发提倡利用多态设计程序架构，因为多态优点很多

### 4.7.3 纯虚函数和抽象类
在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容(猫狗说话，而不是动物说话)  
因此可以将虚函数改为**纯虚函数**  
**纯虚函数语法**：```virtual 返回值类型 函数名 (参数列表) = 0；```  
当类中有了纯虚函数，这个类也成为**抽象类**  
**抽象类特点**：  
- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

ex：
```cpp
#include <iostream>
using namespace std;

class Base
{
public: 
	// 纯虚函数
	// 类中只要有一个纯虚函数，这个类称为抽象类
	// 抽象类特点：
	// 1.抽象类无法实例化对象
	// 2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类
	virtual void func() = 0;
};

class Son : public Base
{
public:
	virtual void func()
	{
		cout << "func调用" << endl;
	}
};

void test1()
{
	// 无法 Base *base 或 Base base
	Base* base = new Son;
	base->func();
	delete base; // 记得销毁进程
}

int main()
{
	test1();
}
```

### 4.7.4 多态案例二-制作饮品
**案例描述**：  
制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料  
利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶  
ex：
```cpp
#include <iostream>
using namespace std;

class DrinkMake
{
public:
	virtual void Zhushui() = 0;
	virtual void Chongpao() = 0;
	virtual void Daoru() = 0;
	virtual void Zuoliao() = 0;

	void make()
	{
		Zhushui();
		Chongpao();
		Daoru();
		Zuoliao();
	}
};

class Caffe : public DrinkMake
{
	void Zhushui()
	{
		cout << "煮恒大冰泉" << endl;
	}

	void Chongpao()
	{
		cout << "冲泡咖啡" << endl;
	}

	void Daoru()
	{
		cout << "倒入杯中" << endl;
	}

	void Zuoliao()
	{
		cout << "加点牛奶和糖" << endl;
	}
};

class Tea :public DrinkMake
{
	void Zhushui()
	{
		cout << "煮自来水" << endl;
	}

	void Chongpao()
	{
		cout << "冲泡茶叶" << endl;
	}

	void Daoru()
	{
		cout << "倒入杯中" << endl;
	}

	void Zuoliao()
	{
		cout << "加点绿叶子" << endl;
	}
};


void test1()
{
	DrinkMake* dm = new Caffe;
	dm->make();
	delete dm;

	cout << "----------------------" << endl;

	dm = new Tea;
	dm->make();
	delete dm;
}

int main()
{
	test1();
	system("pause");
	return 0;
}
```

### 4.7.5 虚析构和纯虚析构
多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码  
**解决方式**：将父类中的析构函数改为**虚析构**或者**纯虚析构**  
虚析构和纯虚析构共性：
- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：
- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：```virtual ~类名(){}```  
纯虚析构语法：```virtual ~类名() = 0``` 后 ```类名::~类名(){}```  
ex：
```cpp
#include <iostream>
using namespace std;

class Animal
{
public:
	Animal()
	{
		cout << "Animal构造函数调用" << endl;
	}
	virtual void Speak() = 0;

	// 利用虚析构可以解决 父类指针释放子类对象时不干净的问题
	//virtual ~Animal()
	//{
	//	cout << "Animal虚析构函数调用！" << endl;
	//}

	// 纯虚析构函数（虚析构和纯虚析构只能存在一个） 需要声明也需要实现
	// 有了纯虚析构之后 这个类也属于抽象类 无法实例化对象
	virtual ~Animal() = 0;
};

Animal::~Animal()
{
	cout << "Animal 纯虚析构函数调用！" << endl;
}

class Cat : public Animal
{
public:
	Cat(string name)
	{
		cout << "Cat构造函数调用" << endl;
		m_name = new string(name); // 堆区数据，需要虚析构函数释放
	}
	virtual void Speak()
	{
		cout << *m_name << "小猫在说话" << endl;
	}
	~Cat()
	{
		cout << "Cat析构函数调用！" << endl;
		if (this->m_name != NULL)
		{
			delete m_name;
			m_name = NULL;
		}
	}

	string* m_name;
};


void test1()
{
	Animal* animal = new Cat("Tom");
	animal->Speak();

	// 父类指针在析构的时候 不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄露
	delete animal;
}

int main()
{
	test1();
	system("pause");
	return 0;
}
```
总结：
1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类

### 4.7.6 多态案例三-电脑组装
**案例描述**：  
电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储）  
将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商  
创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口  
测试时组装三台不同的电脑进行工作  
ex：
```cpp
#include <iostream>
using namespace std;

class CPU
{
public:
	virtual void calculate() = 0; // 虚函数也别忘写public！！
};

class Card
{
public:
	virtual void display() = 0;
};

class Memory
{
public:
	virtual void store() = 0;
};

class Company
{
public:
	Company(CPU* cpu, Card* card, Memory* mem)
	{
		m_cpu = cpu;
		m_card = card;
		m_mem = mem;
	}

	void make()
	{
		m_cpu->calculate();
		m_card->display();
		m_mem->store();
	}

	~Company()
	{
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}

		if (m_card != NULL)
		{
			delete m_card;
		}

		if (m_mem != NULL)
		{
			delete m_mem;
		}
	}

private:
	CPU* m_cpu;
	Card* m_card;
	Memory* m_mem;
};

class IntelCPU :public CPU
{
	virtual void calculate()
	{
		cout << "Intel的CPU制作中" << endl;
	}
};

class IntelCard :public Card
{
	virtual void display()
	{
		cout << "Intel的显卡制作中" << endl;
	}
};

class IntelMem :public Memory
{
	virtual void store()
	{
		cout << "Intel的内存条制作中" << endl;
	}
};

class LenovoCPU :public CPU
{
	virtual void calculate()
	{
		cout << " Lenovo的CPU制作中" << endl;
	}
};

class LenovoCard :public Card
{
	virtual void display()
	{
		cout << " Lenovo的显卡制作中" << endl;
	}
};

class LenovMem :public Memory
{
	virtual void store()
	{
		cout << " Lenovo的内存条制作中" << endl;
	}
};

void test01()
{
	cout << "第一台电脑制作中" << endl;
	Company* c1 = new Company(new IntelCPU, new IntelCard, new IntelMem);
	c1->make();
	delete c1;

	cout << "--------------------------" << endl;
	cout << "第二台电脑制作中" << endl;
	Company* c2 = new Company(new IntelCPU, new IntelCard, new IntelMem);
	c2->make();
	delete c2;

	cout << "--------------------------" << endl;
	cout << "第三台电脑制作中" << endl;
	Company* c3 = new Company(new LenovoCPU, new LenovoCard, new LenovMem);
	c3->make();
	delete c3;
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

&nbsp;
# 五、文件操作
程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放  
通过**文件可以将数据持久化**  
C++中对文件操作需要包含头文件< fstream >  
文件类型分为**两种**：  
1. **文本文件** - 文件以文本的**ASCII码**形式存储在计算机中
2. **二进制文件** - 文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂他们

操作文件的**三大类**：
1. ofstream：写操作
2. ifstream：读操作
3. fstream：读写操作

## 5.1 文本文件
### 5.1.1 写文件
写文件步骤如下：
1. 包含头文件  
#include <fstream>
2. 创建流对象  
ofstream ofs;
3. 打开文件  
ofs.open("文件路径"，打开方式);
4. 写数据  
ofs << "写入的数据"; 
5. 关闭文件  
ofs.close();

文件打开方式：
| 打开方式 | 解释 |
| :----: | :----: |
| ios::in | 为读文件而打开文件 |
| ios::out | 为写文件而打开文件 |
| ios::ate | 初始位置：文件尾 |
| ios::app | 追加方式写文件 |
| ios::trunc | 如果文件存在先删除，再创建 |
| ios::binary | 二进制方式 |

注意：文件打开方式可以配合使用，利用 | 操作符  
例如：用二进制方式写文件```ios::binary | ios::out```  
ex：
```cpp
#include <iostream>
#include <fstream>
using namespace std;

void test01()
{
	ofstream ofs;
	ofs.open("test.txt", ios::out);

	ofs << "姓名：小李" << endl;
	ofs << "年龄：13" << endl;
	ofs << "性别：男" << endl;

	ofs.close();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
	- 文件操作必须包含头文件fstream  
	- 读文件可以利用ostream类，或者fstream类  
	- 打开文件时候需要指定操作文件的路径，以及打开方式  
	- 利用<<可以向文件中写数据  输出流
	- 操作完毕，要关闭文件

### 5.1.2 读文件
>读文件与写文件步骤相似，但是读取方式相对于其比较多

读文件步骤如下：
1. 包含头文件  
#include <fstream>
2. 创建流对象  
ifstream ifs;
3. 打开文件并判断文件是否打开成功 
ifs.open("文件路径"，打开方式);
4. 读数据  
四种方式读取
5. 关闭文件  
ifs.close();

ex：
```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

void test01()
{
	ifstream ifs;
	ifs.open("test.txt", ios::in);

	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	// 第一种
	//char buf[1024] = { 0 };
	//while (ifs >> buf)
	//{
	//	cout << buf << endl;
	//}

	// 第二种
	//char buf[1024] = { 0 };
	//while (ifs.getline(buf, sizeof(buf)))
	//{
	//	cout << buf << endl;
	//}

	// 第三种
	//string buf;
	//while (getline(ifs, buf))
	//{
	//	cout << buf << endl;
	//}

	// 第四种
	char c;
	while ((c = ifs.get()) != EOF)
	{
		cout << c;
	}

	ifs.close();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
>小结：  
	- 读文件可以利用ifstream，或者fstream类  
	- 利用is_open函数可以判断文件是否打开成功  
	- close关闭文件  

## 5.2 二进制文件
>以二进制的方式对文件进行读写操作，打开方式要指定为```ios::binary```

### 5.2.1 写文件
>二进制方式写文件主要利用流对象调用成员函数write

**函数原型**：```ostream& write(const char* buffer, int len);```  
**参数解释**：字符指针buffer指向内存中一段存储空间。len是读写的字节数  
ex：
```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

class Person
{
public:

	char m_Name[64];
	int m_age;
};

void test01()
{
	// 1.包含头文件

	// 2.创建流对象
	ofstream ofs("person.txt", ios::out | ios::binary);

	// 3.打开文件
	//ofs.open("person.txt", ios::out | ios::binary);

	// 4.写文件
	Person p = { "张三", 18 };
	ofs.write((const char*)&p, sizeof(Person));

	// 5.关闭文件
	ofs.close();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```

### 5.2.2 读文件
>二进制方式读文件主要利用流对象调用成员函数read
**函数原型**：```istream& read(char *buffer, int len);  
**参数解释**：字符指针buffer指向内存中一段存储空间。len是读写的字节数  
ex：
```cpp
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

class Person
{
public:

	char m_Name[64];
	int m_age;
};

void test01()
{
	// 1.包含头文件

	// 2.创建流对象
	ifstream ifs;

	// 3.打开文件 判断文件是否打开成功
	ifs.open("person.txt", ios::in | ios::binary);

	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	// 4.读文件
	Person p;
	ifs.read((char*)&p, sizeof(Person)); // 读到Person类的p对象里

	cout << "姓名：" << p.m_Name << " 年龄：" << p.m_age << endl;

	// 5.关闭文件
	ifs.close();
}

int main()
{
	test01();

	system("pause");
	return 0;
}
```
- 文件输入流对象 可以通过read函数 以二进制方式读取数据